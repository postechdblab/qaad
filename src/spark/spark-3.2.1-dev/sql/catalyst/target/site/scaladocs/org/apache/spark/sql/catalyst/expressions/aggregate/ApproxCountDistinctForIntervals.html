<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title>Spark Project Catalyst 3.2.1 API  - org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals</title>
          <meta name="description" content="Spark Project Catalyst 3.2.1 API - org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals" />
          <meta name="keywords" content="Spark Project Catalyst 3.2.1 API org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      
      <link href="../../../../../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../../../../../lib/jquery.min.js"></script>
      <script type="text/javascript" src="../../../../../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../../../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../../../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../../../../../index.js"></script>
      <script type="text/javascript" src="../../../../../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../../../../../lib/template.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../../../../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title">Spark Project Catalyst 3.2.1 API<span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="../../../../../../../index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../../../../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.org" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="org"></a><a id="org:org"></a>
      <span class="permalink">
      <a href="../../../../../../../org/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../../../../index.html"><span class="name">org</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="org.apache" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="apache"></a><a id="apache:apache"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../../../index.html"><span class="name">apache</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../../../index.html" class="extype" name="org">org</a></dd></dl></div>
    </li><li name="org.apache.spark" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="spark"></a><a id="spark:spark"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../../index.html"><span class="name">spark</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../../index.html" class="extype" name="org.apache">apache</a></dd></dl></div>
    </li><li name="org.apache.spark.sql" visbl="pub" class="indented4 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sql"></a><a id="sql:sql"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html"><span class="name">sql</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../index.html" class="extype" name="org.apache.spark">spark</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst" visbl="pub" class="indented5 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="catalyst"></a><a id="catalyst:catalyst"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Catalyst is a library for manipulating relational query plans." href="../../index.html"><span class="name">catalyst</span></a>
      </span>
      
      <p class="shortcomment cmt">Catalyst is a library for manipulating relational query plans.</p><div class="fullcomment"><div class="comment cmt"><p>Catalyst is a library for manipulating relational query plans.  All classes in catalyst are
considered an internal API to Spark SQL and are subject to change between minor releases.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="org.apache.spark.sql">sql</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="expressions"></a><a id="expressions:expressions"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="A set of classes that can be used to represent trees of relational expressions." href="../index.html"><span class="name">expressions</span></a>
      </span>
      
      <p class="shortcomment cmt">A set of classes that can be used to represent trees of relational expressions.</p><div class="fullcomment"><div class="comment cmt"><p>A set of classes that can be used to represent trees of relational expressions.  A key goal of
the expression library is to hide the details of naming and scoping from developers who want to
manipulate trees of relational operators. As such, the library defines a special type of
expression, a <a href="../NamedExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.NamedExpression">NamedExpression</a> in addition to the standard collection of expressions.</p><h4>Standard Expressions</h4><p>A library of standard expressions (e.g., <a href="../Add.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Add">Add</a>, <a href="../EqualTo.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.EqualTo">EqualTo</a>), aggregates (e.g., SUM, COUNT),
and other computations (e.g. UDFs). Each expression type is capable of determining its output
schema as a function of its children's output schema.</p><h4>Named Expressions</h4><p>Some expression are named and thus can be referenced by later operators in the dataflow graph.
The two types of named expressions are <a href="../AttributeReference.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.AttributeReference">AttributeReference</a>s and <a href="../Alias.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Alias">Alias</a>es.
<a href="../AttributeReference.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.AttributeReference">AttributeReference</a>s refer to attributes of the input tuple for a given operator and form
the leaves of some expression trees.  Aliases assign a name to intermediate computations.
For example, in the SQL statement <code>SELECT a+b AS c FROM ...</code>, the expressions <code>a</code> and <code>b</code> would
be represented by <code>AttributeReferences</code> and <code>c</code> would be represented by an <code>Alias</code>.</p><p>During <a href="../../analysis/index.html" class="extype" name="org.apache.spark.sql.catalyst.analysis">analysis</a>, all named expressions are assigned a globally unique expression id, which
can be used for equality comparisons.  While the original names are kept around for debugging
purposes, they should never be used to check if two attributes refer to the same value, as
plan transformations can result in the introduction of naming ambiguity. For example, consider
a plan that contains subqueries, both of which are reading from the same table.  If an
optimization removes the subqueries, scoping information would be destroyed, eliminating the
ability to reason about which subquery produced a given attribute.</p><h4>Evaluation</h4><p>The result of expressions can be evaluated using the <code>Expression.apply(Row)</code> method.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate" visbl="pub" class="indented7 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="aggregate"></a><a id="aggregate:aggregate"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="index.html"><span class="name">aggregate</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst.expressions">expressions</a></dd></dl></div>
    </li><li class="current-entities indented7">
                        <a class="object" href="AggregateExpression$.html" title=""></a>
                        <a class="class" href="AggregateExpression.html" title="A container for an AggregateFunction with its AggregateMode and a field (isDistinct) indicating if DISTINCT keyword is specified for this function and a field (filter) indicating if filter clause is specified for this function."></a>
                        <a href="AggregateExpression.html" title="A container for an AggregateFunction with its AggregateMode and a field (isDistinct) indicating if DISTINCT keyword is specified for this function and a field (filter) indicating if filter clause is specified for this function.">AggregateExpression</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="AggregateFunction.html" title="AggregateFunction is the superclass of two aggregation function interfaces:"></a>
                        <a href="AggregateFunction.html" title="AggregateFunction is the superclass of two aggregation function interfaces:">AggregateFunction</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="trait" href="AggregateMode.html" title="The mode of an AggregateFunction."></a>
                        <a href="AggregateMode.html" title="The mode of an AggregateFunction.">AggregateMode</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="" title="This function counts the approximate number of distinct values (ndv) in intervals constructed from endpoints specified in endpointsExpression."></a>
                        <a href="" title="This function counts the approximate number of distinct values (ndv) in intervals constructed from endpoints specified in endpointsExpression.">ApproxCountDistinctForIntervals</a>
                      </li><li class="current-entities indented7">
                        <a class="object" href="ApproximatePercentile$.html" title=""></a>
                        <a class="class" href="ApproximatePercentile.html" title="The ApproximatePercentile function returns the approximate percentile(s) of a column at the given percentage(s)."></a>
                        <a href="ApproximatePercentile.html" title="The ApproximatePercentile function returns the approximate percentile(s) of a column at the given percentage(s).">ApproximatePercentile</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="Average.html" title=""></a>
                        <a href="Average.html" title="">Average</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="BitAggregate.html" title=""></a>
                        <a href="BitAggregate.html" title="">BitAggregate</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="BitAndAgg.html" title=""></a>
                        <a href="BitAndAgg.html" title="">BitAndAgg</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="BitOrAgg.html" title=""></a>
                        <a href="BitOrAgg.html" title="">BitOrAgg</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="BitXorAgg.html" title=""></a>
                        <a href="BitXorAgg.html" title="">BitXorAgg</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="BoolAnd.html" title=""></a>
                        <a href="BoolAnd.html" title="">BoolAnd</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="BoolOr.html" title=""></a>
                        <a href="BoolOr.html" title="">BoolOr</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="CentralMomentAgg.html" title="A central moment is the expected value of a specified power of the deviation of a random variable from the mean."></a>
                        <a href="CentralMomentAgg.html" title="A central moment is the expected value of a specified power of the deviation of a random variable from the mean.">CentralMomentAgg</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="Collect.html" title="A base class for collect_list and collect_set aggregate functions."></a>
                        <a href="Collect.html" title="A base class for collect_list and collect_set aggregate functions.">Collect</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="CollectList.html" title="Collect a list of elements."></a>
                        <a href="CollectList.html" title="Collect a list of elements.">CollectList</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="CollectSet.html" title="Collect a set of unique elements."></a>
                        <a href="CollectSet.html" title="Collect a set of unique elements.">CollectSet</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="object" href="Complete$.html" title="An AggregateFunction with Complete mode is used to evaluate this function directly from original input rows without any partial aggregation."></a>
                        <a href="Complete$.html" title="An AggregateFunction with Complete mode is used to evaluate this function directly from original input rows without any partial aggregation.">Complete</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="Corr.html" title=""></a>
                        <a href="Corr.html" title="">Corr</a>
                      </li><li class="current-entities indented7">
                        <a class="object" href="Count$.html" title=""></a>
                        <a class="class" href="Count.html" title=""></a>
                        <a href="Count.html" title="">Count</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="CountIf.html" title=""></a>
                        <a href="CountIf.html" title="">CountIf</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="CountMinSketchAgg.html" title="This function returns a count-min sketch of a column with the given esp, confidence and seed."></a>
                        <a href="CountMinSketchAgg.html" title="This function returns a count-min sketch of a column with the given esp, confidence and seed.">CountMinSketchAgg</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="CovPopulation.html" title=""></a>
                        <a href="CovPopulation.html" title="">CovPopulation</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="CovSample.html" title=""></a>
                        <a href="CovSample.html" title="">CovSample</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="Covariance.html" title="Compute the covariance between two expressions."></a>
                        <a href="Covariance.html" title="Compute the covariance between two expressions.">Covariance</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="DeclarativeAggregate.html" title="API for aggregation functions that are expressed in terms of Catalyst expressions."></a>
                        <a href="DeclarativeAggregate.html" title="API for aggregation functions that are expressed in terms of Catalyst expressions.">DeclarativeAggregate</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="object" href="Final$.html" title="An AggregateFunction with Final mode is used to merge aggregation buffers containing intermediate results for this function and then generate final result."></a>
                        <a href="Final$.html" title="An AggregateFunction with Final mode is used to merge aggregation buffers containing intermediate results for this function and then generate final result.">Final</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="First.html" title="Returns the first value of child for a group of rows."></a>
                        <a href="First.html" title="Returns the first value of child for a group of rows.">First</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="object" href="FirstLast$.html" title=""></a>
                        <a href="FirstLast$.html" title="">FirstLast</a>
                      </li><li class="current-entities indented7">
                        <a class="object" href="HyperLogLogPlusPlus$.html" title=""></a>
                        <a class="class" href="HyperLogLogPlusPlus.html" title="HyperLogLog++ (HLL++) is a state of the art cardinality estimation algorithm."></a>
                        <a href="HyperLogLogPlusPlus.html" title="HyperLogLog++ (HLL++) is a state of the art cardinality estimation algorithm.">HyperLogLogPlusPlus</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="ImperativeAggregate.html" title="API for aggregation functions that are expressed in terms of imperative initialize(), update(), and merge() functions which operate on Row-based aggregation buffers."></a>
                        <a href="ImperativeAggregate.html" title="API for aggregation functions that are expressed in terms of imperative initialize(), update(), and merge() functions which operate on Row-based aggregation buffers.">ImperativeAggregate</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="Kurtosis.html" title=""></a>
                        <a href="Kurtosis.html" title="">Kurtosis</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="Last.html" title="Returns the last value of child for a group of rows."></a>
                        <a href="Last.html" title="Returns the last value of child for a group of rows.">Last</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="Max.html" title=""></a>
                        <a href="Max.html" title="">Max</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="MaxBy.html" title=""></a>
                        <a href="MaxBy.html" title="">MaxBy</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="MaxMinBy.html" title="The shared abstract superclass for MaxBy and MinBy SQL aggregate functions."></a>
                        <a href="MaxMinBy.html" title="The shared abstract superclass for MaxBy and MinBy SQL aggregate functions.">MaxMinBy</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="Min.html" title=""></a>
                        <a href="Min.html" title="">Min</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="MinBy.html" title=""></a>
                        <a href="MinBy.html" title="">MinBy</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="object" href="NoOp$.html" title="A place holder expressions used in code-gen, it does not change the corresponding value in the row."></a>
                        <a href="NoOp$.html" title="A place holder expressions used in code-gen, it does not change the corresponding value in the row.">NoOp</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="object" href="Partial$.html" title="An AggregateFunction with Partial mode is used for partial aggregation."></a>
                        <a href="Partial$.html" title="An AggregateFunction with Partial mode is used for partial aggregation.">Partial</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="object" href="PartialMerge$.html" title="An AggregateFunction with PartialMerge mode is used to merge aggregation buffers containing intermediate results for this function."></a>
                        <a href="PartialMerge$.html" title="An AggregateFunction with PartialMerge mode is used to merge aggregation buffers containing intermediate results for this function.">PartialMerge</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="PearsonCorrelation.html" title="Base class for computing Pearson correlation between two expressions."></a>
                        <a href="PearsonCorrelation.html" title="Base class for computing Pearson correlation between two expressions.">PearsonCorrelation</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="Percentile.html" title="The Percentile aggregate function returns the exact percentile(s) of numeric column expr at the given percentage(s) with value range in [0.0, 1.0]."></a>
                        <a href="Percentile.html" title="The Percentile aggregate function returns the exact percentile(s) of numeric column expr at the given percentage(s) with value range in [0.0, 1.0].">Percentile</a>
                      </li><li class="current-entities indented7">
                        <a class="object" href="PivotFirst$.html" title=""></a>
                        <a class="class" href="PivotFirst.html" title="PivotFirst is an aggregate function used in the second phase of a two phase pivot to do the required rearrangement of values into pivoted form."></a>
                        <a href="PivotFirst.html" title="PivotFirst is an aggregate function used in the second phase of a two phase pivot to do the required rearrangement of values into pivoted form.">PivotFirst</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="Product.html" title="Multiply numerical values within an aggregation group"></a>
                        <a href="Product.html" title="Multiply numerical values within an aggregation group">Product</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="Skewness.html" title=""></a>
                        <a href="Skewness.html" title="">Skewness</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="StddevPop.html" title=""></a>
                        <a href="StddevPop.html" title="">StddevPop</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="StddevSamp.html" title=""></a>
                        <a href="StddevSamp.html" title="">StddevSamp</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="Sum.html" title=""></a>
                        <a href="Sum.html" title="">Sum</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="TypedImperativeAggregate.html" title="Aggregation function which allows **arbitrary** user-defined java object to be used as internal aggregation buffer."></a>
                        <a href="TypedImperativeAggregate.html" title="Aggregation function which allows **arbitrary** user-defined java object to be used as internal aggregation buffer.">TypedImperativeAggregate</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="UnevaluableBooleanAggBase.html" title=""></a>
                        <a href="UnevaluableBooleanAggBase.html" title="">UnevaluableBooleanAggBase</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="V2Aggregator.html" title=""></a>
                        <a href="V2Aggregator.html" title="">V2Aggregator</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="VariancePop.html" title=""></a>
                        <a href="VariancePop.html" title="">VariancePop</a>
                      </li><li class="current-entities indented7">
                        <span class="separator"></span>
                        <a class="class" href="VarianceSamp.html" title=""></a>
                        <a href="VarianceSamp.html" title="">VarianceSamp</a>
                      </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="class type">
      <div id="definition">
        <div class="big-circle class">c</div>
        <p id="owner"><a href="../../../../../../index.html" class="extype" name="org">org</a>.<a href="../../../../../index.html" class="extype" name="org.apache">apache</a>.<a href="../../../../index.html" class="extype" name="org.apache.spark">spark</a>.<a href="../../../index.html" class="extype" name="org.apache.spark.sql">sql</a>.<a href="../../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a>.<a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst.expressions">expressions</a>.<a href="index.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate">aggregate</a></p>
        <h1>ApproxCountDistinctForIntervals<span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        <h3><span class="morelinks"></span></h3>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <span class="name">ApproxCountDistinctForIntervals</span><span class="params">(<span name="child">child: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>, <span name="endpointsExpression">endpointsExpression: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>, <span name="relativeSD">relativeSD: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">0.05</span></span>, <span name="mutableAggBufferOffset">mutableAggBufferOffset: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>, <span name="inputAggBufferOffset">inputAggBufferOffset: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>)</span><span class="result"> extends <a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]] with <a href="../ExpectsInputTypes.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.ExpectsInputTypes">ExpectsInputTypes</a> with <a href="../../trees/BinaryLike.html" class="extype" name="org.apache.spark.sql.catalyst.trees.BinaryLike">BinaryLike</a>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>] with <span class="extype" name="scala.Product">scala.Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>This function counts the approximate number of distinct values (ndv) in
intervals constructed from endpoints specified in <code>endpointsExpression</code>. The endpoints should be
sorted into ascending order. E.g., given an array of endpoints
(endpoint_1, endpoint_2, ... endpoint_N), returns the approximate ndv's for intervals
[endpoint_1, endpoint_2], (endpoint_2, endpoint_3], ... (endpoint_N-1, endpoint_N].
To count ndv's in these intervals, apply the HyperLogLogPlusPlus algorithm in each of them.</p></div><dl class="paramcmts block"><dt class="param">child</dt><dd class="cmt"><p>to estimate the ndv's of.</p></dd><dt class="param">endpointsExpression</dt><dd class="cmt"><p>An array expression to construct the intervals. It must be foldable,
                           and its elements should be sorted into ascending order.
                           Duplicate endpoints are allowed, e.g. (1, 5, 5, 10), and ndv for
                           interval (5, 5] would be 1.</p></dd><dt class="param">relativeSD</dt><dd class="cmt"><p>The maximum relative standard deviation allowed
                  in the HyperLogLogPlusPlus algorithm.</p></dd></dl><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.Serializable">Serializable</span>, <span class="extype" name="java.io.Serializable">Serializable</span>, <a href="../../trees/BinaryLike.html" class="extype" name="org.apache.spark.sql.catalyst.trees.BinaryLike">BinaryLike</a>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>], <a href="../ExpectsInputTypes.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.ExpectsInputTypes">ExpectsInputTypes</a>, <a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]], <a href="ImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ImperativeAggregate">ImperativeAggregate</a>, <a href="../codegen/CodegenFallback.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback">CodegenFallback</a>, <a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a>, <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>, <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>], <a href="../../trees/TreePatternBits.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreePatternBits">TreePatternBits</a>, <span class="extype" name="scala.Product">scala.Product</span>, <span class="extype" name="scala.Equals">Equals</span>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals"><span>ApproxCountDistinctForIntervals</span></li><li class="in" name="scala.Serializable"><span>Serializable</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="org.apache.spark.sql.catalyst.trees.BinaryLike"><span>BinaryLike</span></li><li class="in" name="org.apache.spark.sql.catalyst.expressions.ExpectsInputTypes"><span>ExpectsInputTypes</span></li><li class="in" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate"><span>TypedImperativeAggregate</span></li><li class="in" name="org.apache.spark.sql.catalyst.expressions.aggregate.ImperativeAggregate"><span>ImperativeAggregate</span></li><li class="in" name="org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback"><span>CodegenFallback</span></li><li class="in" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction"><span>AggregateFunction</span></li><li class="in" name="org.apache.spark.sql.catalyst.expressions.Expression"><span>Expression</span></li><li class="in" name="org.apache.spark.sql.catalyst.trees.TreeNode"><span>TreeNode</span></li><li class="in" name="org.apache.spark.sql.catalyst.trees.TreePatternBits"><span>TreePatternBits</span></li><li class="in" name="scala.Product"><span>Product</span></li><li class="in" name="scala.Equals"><span>Equals</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div id="constructors" class="members">
              <h3>Instance Constructors</h3>
              <ol><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#&lt;init&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="&lt;init&gt;(child:org.apache.spark.sql.catalyst.expressions.Expression,endpointsExpression:org.apache.spark.sql.catalyst.expressions.Expression,relativeSD:org.apache.spark.sql.catalyst.expressions.Expression):org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals"></a><a id="&lt;init&gt;:ApproxCountDistinctForIntervals"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#&lt;init&gt;(child:org.apache.spark.sql.catalyst.expressions.Expression,endpointsExpression:org.apache.spark.sql.catalyst.expressions.Expression,relativeSD:org.apache.spark.sql.catalyst.expressions.Expression):org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">ApproxCountDistinctForIntervals</span><span class="params">(<span name="child">child: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>, <span name="endpointsExpression">endpointsExpression: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>, <span name="relativeSD">relativeSD: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>)</span>
      </span>
      
      
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#&lt;init&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;init&gt;(child:org.apache.spark.sql.catalyst.expressions.Expression,endpointsExpression:org.apache.spark.sql.catalyst.expressions.Expression,relativeSD:Double,mutableAggBufferOffset:Int,inputAggBufferOffset:Int):org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals"></a><a id="&lt;init&gt;:ApproxCountDistinctForIntervals"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#&lt;init&gt;(child:org.apache.spark.sql.catalyst.expressions.Expression,endpointsExpression:org.apache.spark.sql.catalyst.expressions.Expression,relativeSD:Double,mutableAggBufferOffset:Int,inputAggBufferOffset:Int):org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">ApproxCountDistinctForIntervals</span><span class="params">(<span name="child">child: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>, <span name="endpointsExpression">endpointsExpression: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>, <span name="relativeSD">relativeSD: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">0.05</span></span>, <span name="mutableAggBufferOffset">mutableAggBufferOffset: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>, <span name="inputAggBufferOffset">inputAggBufferOffset: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>)</span>
      </span>
      
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt class="param">child</dt><dd class="cmt"><p>to estimate the ndv's of.</p></dd><dt class="param">endpointsExpression</dt><dd class="cmt"><p>An array expression to construct the intervals. It must be foldable,
                           and its elements should be sorted into ascending order.
                           Duplicate endpoints are allowed, e.g. (1, 5, 5, 10), and ndv for
                           interval (5, 5] would be 1.</p></dd><dt class="param">relativeSD</dt><dd class="cmt"><p>The maximum relative standard deviation allowed
                  in the HyperLogLogPlusPlus algorithm.</p></dd></dl></div>
    </li></ol>
            </div>

        

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="scala.AnyRef#!=" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#!=(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html###():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#==(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate#aggBufferAttributes" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="aggBufferAttributes:Seq[org.apache.spark.sql.catalyst.expressions.AttributeReference]"></a><a id="aggBufferAttributes:Seq[AttributeReference]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#aggBufferAttributes:Seq[org.apache.spark.sql.catalyst.expressions.AttributeReference]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">aggBufferAttributes</span><span class="result">: <span class="extype" name="scala.Seq">Seq</span>[<a href="../AttributeReference.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.AttributeReference">AttributeReference</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Attributes of fields in aggBufferSchema.</p><div class="fullcomment"><div class="comment cmt"><p>Attributes of fields in aggBufferSchema.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a> → <a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate#aggBufferSchema" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="aggBufferSchema:org.apache.spark.sql.types.StructType"></a><a id="aggBufferSchema:StructType"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#aggBufferSchema:org.apache.spark.sql.types.StructType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">aggBufferSchema</span><span class="result">: <a href="../../../types/StructType.html" class="extype" name="org.apache.spark.sql.types.StructType">StructType</a></span>
      </span>
      
      <p class="shortcomment cmt">The schema of the aggregation buffer.</p><div class="fullcomment"><div class="comment cmt"><p>The schema of the aggregation buffer.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a> → <a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#apply" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="apply(number:Int):org.apache.spark.sql.catalyst.trees.TreeNode[_]"></a><a id="apply(Int):TreeNode[_]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#apply(number:Int):org.apache.spark.sql.catalyst.trees.TreeNode[_]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">(<span name="number">number: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a>[_]</span>
      </span>
      
      <p class="shortcomment cmt">Returns the tree node at the specified number, used primarily for interactive debugging.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the tree node at the specified number, used primarily for interactive debugging.
Numbers for each node can be found in the <a href="../../trees/TreeNode.html#numberedTreeString:String" class="extmbr" name="org.apache.spark.sql.catalyst.trees.TreeNode#numberedTreeString">numberedTreeString</a>.</p><p>Note that this cannot return BaseType because logical plan's plan node might return
physical plan for innerChildren, e.g. in-memory relation logical plan node has a reference
to the physical plan node it is referencing.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#argString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="argString(maxFields:Int):String"></a><a id="argString(Int):String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#argString(maxFields:Int):String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">argString</span><span class="params">(<span name="maxFields">maxFields: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <p class="shortcomment cmt">Returns a string representing the arguments to this node, minus any children</p><div class="fullcomment"><div class="comment cmt"><p>Returns a string representing the arguments to this node, minus any children</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#asCode" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asCode:String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#asCode:String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asCode</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <p class="shortcomment cmt">Returns a 'scala code' representation of this <code>TreeNode</code> and its children.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a 'scala code' representation of this <code>TreeNode</code> and its children.  Intended for use
when debugging where the prettier toString function is obfuscating the actual structure. In the
case of 'pure' <code>TreeNodes</code> that only contain primitives and other TreeNodes, the result can be
pasted in the REPL to build an equivalent Tree.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#asInstanceOf[T0]:T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#canonicalized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="canonicalized:org.apache.spark.sql.catalyst.expressions.Expression"></a><a id="canonicalized:Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#canonicalized:org.apache.spark.sql.catalyst.expressions.Expression" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">canonicalized</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns an expression where a best effort attempt has been made to transform <code>this</code> in a way
that preserves the result but removes cosmetic variations (case sensitivity, ordering for
commutative operations, etc.)  See <a href="../Canonicalize$.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Canonicalize">Canonicalize</a> for more details.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an expression where a best effort attempt has been made to transform <code>this</code> in a way
that preserves the result but removes cosmetic variations (case sensitivity, ordering for
commutative operations, etc.)  See <a href="../Canonicalize$.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Canonicalize">Canonicalize</a> for more details.</p><p><code>deterministic</code> expressions where <code>this.canonicalized == other.canonicalized</code> will always
evaluate to the same result.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#checkInputDataTypes" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="checkInputDataTypes():org.apache.spark.sql.catalyst.analysis.TypeCheckResult"></a><a id="checkInputDataTypes():TypeCheckResult"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#checkInputDataTypes():org.apache.spark.sql.catalyst.analysis.TypeCheckResult" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">checkInputDataTypes</span><span class="params">()</span><span class="result">: <a href="../../analysis/TypeCheckResult.html" class="extype" name="org.apache.spark.sql.catalyst.analysis.TypeCheckResult">TypeCheckResult</a></span>
      </span>
      
      <p class="shortcomment cmt">Checks the input data types, returns <code>TypeCheckResult.success</code> if it's valid,
or returns a <code>TypeCheckResult</code> with an error message if invalid.</p><div class="fullcomment"><div class="comment cmt"><p>Checks the input data types, returns <code>TypeCheckResult.success</code> if it's valid,
or returns a <code>TypeCheckResult</code> with an error message if invalid.
Note: it's not valid to call this method until <code>childrenResolved == true</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="../ExpectsInputTypes.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.ExpectsInputTypes">ExpectsInputTypes</a> → <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#child" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="child:org.apache.spark.sql.catalyst.expressions.Expression"></a><a id="child:Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#child:org.apache.spark.sql.catalyst.expressions.Expression" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">child</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      
    </li><li name="org.apache.spark.sql.catalyst.trees.BinaryLike#children" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="children:Seq[T]"></a><a id="children:Seq[Expression]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#children:Seq[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">children</span><span class="result">: <span class="extype" name="scala.Seq">Seq</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/BinaryLike.html" class="extype" name="org.apache.spark.sql.catalyst.trees.BinaryLike">BinaryLike</a></dd><dt>Annotations</dt><dd>
                <span class="name">@transient</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#childrenResolved" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="childrenResolved:Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#childrenResolved:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">childrenResolved</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <p class="shortcomment cmt">Returns true if  all the children of this expression have been resolved to a specific schema
and false if any still contains any unresolved placeholders.</p><div class="fullcomment"><div class="comment cmt"><p>Returns true if  all the children of this expression have been resolved to a specific schema
and false if any still contains any unresolved placeholders.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#clone" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():BaseType"></a><a id="clone():Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#clone():BaseType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a> → AnyRef</dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#collect" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collect[B](pf:PartialFunction[BaseType,B]):Seq[B]"></a><a id="collect[B](PartialFunction[Expression,B]):Seq[B]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#collect[B](pf:PartialFunction[BaseType,B]):Seq[B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collect</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="pf">pf: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>, <span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.collect.B">B</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.collect.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a Seq containing the result of applying a partial function to all elements in this
tree on which the function is defined.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a Seq containing the result of applying a partial function to all elements in this
tree on which the function is defined.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#collectFirst" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collectFirst[B](pf:PartialFunction[BaseType,B]):Option[B]"></a><a id="collectFirst[B](PartialFunction[Expression,B]):Option[B]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#collectFirst[B](pf:PartialFunction[BaseType,B]):Option[B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collectFirst</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="pf">pf: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>, <span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.collectFirst.B">B</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.collectFirst.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Finds and returns the first <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a> of the tree for which the given partial function
is defined (pre-order), and applies the partial function to it.</p><div class="fullcomment"><div class="comment cmt"><p>Finds and returns the first <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a> of the tree for which the given partial function
is defined (pre-order), and applies the partial function to it.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#collectLeaves" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collectLeaves():Seq[BaseType]"></a><a id="collectLeaves():Seq[Expression]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#collectLeaves():Seq[BaseType]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collectLeaves</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Seq">Seq</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a Seq containing the leaves in this tree.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a Seq containing the leaves in this tree.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreePatternBits#containsAllPatterns" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="containsAllPatterns(patterns:org.apache.spark.sql.catalyst.trees.TreePattern.TreePattern*):Boolean"></a><a id="containsAllPatterns(TreePattern*):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#containsAllPatterns(patterns:org.apache.spark.sql.catalyst.trees.TreePattern.TreePattern*):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">containsAllPatterns</span><span class="params">(<span name="patterns">patterns: <a href="../../trees/TreePattern$.html#TreePattern=org.apache.spark.sql.catalyst.trees.TreePattern.Value" class="extmbr" name="org.apache.spark.sql.catalyst.trees.TreePattern.TreePattern">TreePattern</a>*</span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if every bit for <code>patterns</code> is set; false otherwise.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreePatternBits.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreePatternBits">TreePatternBits</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreePatternBits#containsAnyPattern" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="containsAnyPattern(patterns:org.apache.spark.sql.catalyst.trees.TreePattern.TreePattern*):Boolean"></a><a id="containsAnyPattern(TreePattern*):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#containsAnyPattern(patterns:org.apache.spark.sql.catalyst.trees.TreePattern.TreePattern*):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">containsAnyPattern</span><span class="params">(<span name="patterns">patterns: <a href="../../trees/TreePattern$.html#TreePattern=org.apache.spark.sql.catalyst.trees.TreePattern.Value" class="extmbr" name="org.apache.spark.sql.catalyst.trees.TreePattern.TreePattern">TreePattern</a>*</span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if at least one bit for <code>patterns</code> is set; false otherwise.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreePatternBits.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreePatternBits">TreePatternBits</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#containsChild" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="containsChild:Set[org.apache.spark.sql.catalyst.trees.TreeNode[_]]"></a><a id="containsChild:Set[TreeNode[_]]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#containsChild:Set[org.apache.spark.sql.catalyst.trees.TreeNode[_]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">containsChild</span><span class="result">: <span class="extype" name="scala.Predef.Set">Set</span>[<a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a>[_]]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreePatternBits#containsPattern" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="containsPattern(t:org.apache.spark.sql.catalyst.trees.TreePattern.TreePattern):Boolean"></a><a id="containsPattern(TreePattern):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#containsPattern(t:org.apache.spark.sql.catalyst.trees.TreePattern.TreePattern):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">containsPattern</span><span class="params">(<span name="t">t: <a href="../../trees/TreePattern$.html#TreePattern=org.apache.spark.sql.catalyst.trees.TreePattern.Value" class="extmbr" name="org.apache.spark.sql.catalyst.trees.TreePattern.TreePattern">TreePattern</a></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if the bit for <code>t</code> is set; false otherwise.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreePatternBits.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreePatternBits">TreePatternBits</a></dd><dt>Annotations</dt><dd>
                <span class="name">@inline</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#copyTagsFrom" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="copyTagsFrom(other:BaseType):Unit"></a><a id="copyTagsFrom(Expression):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#copyTagsFrom(other:BaseType):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">copyTagsFrom</span><span class="params">(<span name="other">other: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#createAggregationBuffer" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="createAggregationBuffer():Array[Long]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#createAggregationBuffer():Array[Long]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">createAggregationBuffer</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Allocate enough words to store all registers.</p><div class="fullcomment"><div class="comment cmt"><p>Allocate enough words to store all registers.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an aggregation buffer object</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#dataType" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dataType:org.apache.spark.sql.types.DataType"></a><a id="dataType:DataType"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#dataType:org.apache.spark.sql.types.DataType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dataType</span><span class="result">: <a href="../../../types/DataType.html" class="extype" name="org.apache.spark.sql.types.DataType">DataType</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns the <span class="extype" name="DataType">DataType</span> of the result of evaluating this expression.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the <span class="extype" name="DataType">DataType</span> of the result of evaluating this expression.  It is
invalid to query the dataType of an unresolved expression (i.e., when <code>resolved</code> == false).
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction#defaultResult" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="defaultResult:Option[org.apache.spark.sql.catalyst.expressions.Literal]"></a><a id="defaultResult:Option[Literal]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#defaultResult:Option[org.apache.spark.sql.catalyst.expressions.Literal]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">defaultResult</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<a href="../Literal.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Literal">Literal</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Result of the aggregate function when the input is empty.</p><div class="fullcomment"><div class="comment cmt"><p>Result of the aggregate function when the input is empty.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#deserialize" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="deserialize(bytes:Array[Byte]):Array[Long]"></a><a id="deserialize(Array[Byte]):Array[Long]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#deserialize(bytes:Array[Byte]):Array[Long]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">deserialize</span><span class="params">(<span name="bytes">bytes: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      
      <p class="shortcomment cmt">De-serializes the serialized format Array[Byte], and produces aggregation buffer object T</p><div class="fullcomment"><div class="comment cmt"><p>De-serializes the serialized format Array[Byte], and produces aggregation buffer object T</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#deterministic" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="deterministic:Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#deterministic:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">deterministic</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <p class="shortcomment cmt">Returns true when the current expression always return the same result for fixed inputs from
children.</p><div class="fullcomment"><div class="comment cmt"><p>Returns true when the current expression always return the same result for fixed inputs from
children. The non-deterministic expressions should not change in number and order. They should
not be evaluated during the query planning.</p><p>Note that this means that an expression should be considered as non-deterministic if:
- it relies on some mutable internal state, or
- it relies on some implicit input that is not part of the children expression list.
- it has non-deterministic child or children.
- it assumes the input satisfies some certain condition via the child operator.</p><p>An example would be <code>SparkPartitionID</code> that relies on the partition id returned by TaskContext.
By default leaf expressions are deterministic as Nil.forall(_.deterministic) returns true.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback#doGenCode" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doGenCode(ctx:org.apache.spark.sql.catalyst.expressions.codegen.CodegenContext,ev:org.apache.spark.sql.catalyst.expressions.codegen.ExprCode):org.apache.spark.sql.catalyst.expressions.codegen.ExprCode"></a><a id="doGenCode(CodegenContext,ExprCode):ExprCode"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#doGenCode(ctx:org.apache.spark.sql.catalyst.expressions.codegen.CodegenContext,ev:org.apache.spark.sql.catalyst.expressions.codegen.ExprCode):org.apache.spark.sql.catalyst.expressions.codegen.ExprCode" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doGenCode</span><span class="params">(<span name="ctx">ctx: <a href="../codegen/CodegenContext.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.codegen.CodegenContext">CodegenContext</a></span>, <span name="ev">ev: <a href="../codegen/ExprCode.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.codegen.ExprCode">ExprCode</a></span>)</span><span class="result">: <a href="../codegen/ExprCode.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.codegen.ExprCode">ExprCode</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns Java source code that can be compiled to evaluate this expression.</p><div class="fullcomment"><div class="comment cmt"><p>Returns Java source code that can be compiled to evaluate this expression.
The default behavior is to call the eval method of the expression. Concrete expression
implementations should override this to do actual code generation.
</p></div><dl class="paramcmts block"><dt class="param">ctx</dt><dd class="cmt"><p>a <a href="../codegen/CodegenContext.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.codegen.CodegenContext">CodegenContext</a></p></dd><dt class="param">ev</dt><dd class="cmt"><p>an <a href="../codegen/ExprCode.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.codegen.ExprCode">ExprCode</a> with unique terms.</p></dd><dt>returns</dt><dd class="cmt"><p>an <a href="../codegen/ExprCode.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.codegen.ExprCode">ExprCode</a> containing the Java source code to generate the given expression</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../codegen/CodegenFallback.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback">CodegenFallback</a> → <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#endpoints" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="endpoints:Array[Double]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#endpoints:Array[Double]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">endpoints</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Double">Double</span>]</span>
      </span>
      
      
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#endpointsExpression" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="endpointsExpression:org.apache.spark.sql.catalyst.expressions.Expression"></a><a id="endpointsExpression:Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#endpointsExpression:org.apache.spark.sql.catalyst.expressions.Expression" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">endpointsExpression</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      
    </li><li name="scala.AnyRef#eq" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#eq(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#eval" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eval(buffer:Array[Long]):Any"></a><a id="eval(Array[Long]):Any"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#eval(buffer:Array[Long]):Any" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eval</span><span class="params">(<span name="buffer">buffer: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Any">Any</span></span>
      </span>
      
      <p class="shortcomment cmt">Generates the final aggregation result value for current key group with the aggregation buffer
object.</p><div class="fullcomment"><div class="comment cmt"><p>Generates the final aggregation result value for current key group with the aggregation buffer
object.</p><p>Developer note: the only return types accepted by Spark are:</p><ul><li>primitive types</li><li>InternalRow and subclasses</li><li>ArrayData</li><li>MapData
</li></ul></div><dl class="paramcmts block"><dt class="param">buffer</dt><dd class="cmt"><p>aggregation buffer object.</p></dd><dt>returns</dt><dd class="cmt"><p>The aggregation result of current key group</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate#eval" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eval(buffer:org.apache.spark.sql.catalyst.InternalRow):Any"></a><a id="eval(InternalRow):Any"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#eval(buffer:org.apache.spark.sql.catalyst.InternalRow):Any" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eval</span><span class="params">(<span name="buffer">buffer: <a href="../../InternalRow.html" class="extype" name="org.apache.spark.sql.catalyst.InternalRow">InternalRow</a></span>)</span><span class="result">: <span class="extype" name="scala.Any">Any</span></span>
      </span>
      
      <p class="shortcomment cmt">Returns the result of evaluating this expression on a given input Row</p><div class="fullcomment"><div class="comment cmt"><p>Returns the result of evaluating this expression on a given input Row</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a> → <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#fastEquals" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fastEquals(other:org.apache.spark.sql.catalyst.trees.TreeNode[_]):Boolean"></a><a id="fastEquals(TreeNode[_]):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#fastEquals(other:org.apache.spark.sql.catalyst.trees.TreeNode[_]):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fastEquals</span><span class="params">(<span name="other">other: <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a>[_]</span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <p class="shortcomment cmt">Faster version of equality which short-circuits when two treeNodes are the same instance.</p><div class="fullcomment"><div class="comment cmt"><p>Faster version of equality which short-circuits when two treeNodes are the same instance.
We don't just override Object.equals, as doing so prevents the scala compiler from
generating case class <code>equals</code> methods
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#finalize():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#find" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="find(f:BaseType=&gt;Boolean):Option[BaseType]"></a><a id="find((Expression)⇒Boolean):Option[Expression]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#find(f:BaseType=&gt;Boolean):Option[BaseType]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">find</span><span class="params">(<span name="f">f: (<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Find the first <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a> that satisfies the condition specified by <code>f</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Find the first <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a> that satisfies the condition specified by <code>f</code>.
The condition is recursively applied to this node and all of its children (pre-order).
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#findHllppIndex" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="findHllppIndex(value:Double):Int"></a><a id="findHllppIndex(Double):Int"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#findHllppIndex(value:Double):Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">findHllppIndex</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#flatArguments" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatArguments:Iterator[Any]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#flatArguments:Iterator[Any]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatArguments</span><span class="result">: <span class="extype" name="scala.Iterator">Iterator</span>[<span class="extype" name="scala.Any">Any</span>]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#flatMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatMap[A](f:BaseType=&gt;TraversableOnce[A]):Seq[A]"></a><a id="flatMap[A]((Expression)⇒TraversableOnce[A]):Seq[A]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#flatMap[A](f:BaseType=&gt;TraversableOnce[A]):Seq[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMap</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="f">f: (<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>) ⇒ <span class="extype" name="scala.TraversableOnce">TraversableOnce</span>[<span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.flatMap.A">A</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.flatMap.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a Seq by applying a function to all nodes in this tree and using the elements of the
resulting collections.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a Seq by applying a function to all nodes in this tree and using the elements of the
resulting collections.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction#foldable" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="foldable:Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#foldable:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foldable</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <p class="shortcomment cmt">An aggregate function is not foldable.</p><div class="fullcomment"><div class="comment cmt"><p>An aggregate function is not foldable.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a> → <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#foreach" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="foreach(f:BaseType=&gt;Unit):Unit"></a><a id="foreach((Expression)⇒Unit):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#foreach(f:BaseType=&gt;Unit):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foreach</span><span class="params">(<span name="f">f: (<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Runs the given function on this node and then recursively on <a href="../../trees/TreeNode.html#children:Seq[BaseType]" class="extmbr" name="org.apache.spark.sql.catalyst.trees.TreeNode#children">children</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Runs the given function on this node and then recursively on <a href="../../trees/TreeNode.html#children:Seq[BaseType]" class="extmbr" name="org.apache.spark.sql.catalyst.trees.TreeNode#children">children</a>.</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to be applied to each node in the tree.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#foreachUp" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="foreachUp(f:BaseType=&gt;Unit):Unit"></a><a id="foreachUp((Expression)⇒Unit):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#foreachUp(f:BaseType=&gt;Unit):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foreachUp</span><span class="params">(<span name="f">f: (<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Runs the given function recursively on <a href="../../trees/TreeNode.html#children:Seq[BaseType]" class="extmbr" name="org.apache.spark.sql.catalyst.trees.TreeNode#children">children</a> then on this node.</p><div class="fullcomment"><div class="comment cmt"><p>Runs the given function recursively on <a href="../../trees/TreeNode.html#children:Seq[BaseType]" class="extmbr" name="org.apache.spark.sql.catalyst.trees.TreeNode#children">children</a> then on this node.</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to be applied to each node in the tree.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#genCode" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="genCode(ctx:org.apache.spark.sql.catalyst.expressions.codegen.CodegenContext):org.apache.spark.sql.catalyst.expressions.codegen.ExprCode"></a><a id="genCode(CodegenContext):ExprCode"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#genCode(ctx:org.apache.spark.sql.catalyst.expressions.codegen.CodegenContext):org.apache.spark.sql.catalyst.expressions.codegen.ExprCode" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">genCode</span><span class="params">(<span name="ctx">ctx: <a href="../codegen/CodegenContext.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.codegen.CodegenContext">CodegenContext</a></span>)</span><span class="result">: <a href="../codegen/ExprCode.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.codegen.ExprCode">ExprCode</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns an <span class="extype" name="ExprCode">ExprCode</span>, that contains the Java source code to generate the result of
evaluating the expression on an input row.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an <span class="extype" name="ExprCode">ExprCode</span>, that contains the Java source code to generate the result of
evaluating the expression on an input row.
</p></div><dl class="paramcmts block"><dt class="param">ctx</dt><dd class="cmt"><p>a <span class="extype" name="CodegenContext">CodegenContext</span></p></dd><dt>returns</dt><dd class="cmt"><p><span class="extype" name="ExprCode">ExprCode</span></p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#generateTreeString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="generateTreeString(depth:Int,lastChildren:Seq[Boolean],append:String=&gt;Unit,verbose:Boolean,prefix:String,addSuffix:Boolean,maxFields:Int,printNodeId:Boolean,indent:Int):Unit"></a><a id="generateTreeString(Int,Seq[Boolean],(String)⇒Unit,Boolean,String,Boolean,Int,Boolean,Int):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#generateTreeString(depth:Int,lastChildren:Seq[Boolean],append:String=&gt;Unit,verbose:Boolean,prefix:String,addSuffix:Boolean,maxFields:Int,printNodeId:Boolean,indent:Int):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">generateTreeString</span><span class="params">(<span name="depth">depth: <span class="extype" name="scala.Int">Int</span></span>, <span name="lastChildren">lastChildren: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>, <span name="append">append: (<span class="extype" name="scala.Predef.String">String</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="verbose">verbose: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="prefix">prefix: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">&quot;&quot;</span></span>, <span name="addSuffix">addSuffix: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="maxFields">maxFields: <span class="extype" name="scala.Int">Int</span></span>, <span name="printNodeId">printNodeId: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="indent">indent: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Appends the string representation of this node and its children to the given Writer.</p><div class="fullcomment"><div class="comment cmt"><p>Appends the string representation of this node and its children to the given Writer.</p><p>The <code>i</code>-th element in <code>lastChildren</code> indicates whether the ancestor of the current node at
depth <code>i + 1</code> is the last child of its own parent node.  The depth of the root node is 0, and
<code>lastChildren</code> for the root node should be empty.</p><p>Note that this traversal (numbering) order must be the same as <span class="extype" name="getNodeNumbered">getNodeNumbered</span>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#getClass():Class[_]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#getDefaultTreePatternBits" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getDefaultTreePatternBits:org.apache.spark.util.collection.BitSet"></a><a id="getDefaultTreePatternBits:BitSet"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#getDefaultTreePatternBits:org.apache.spark.util.collection.BitSet" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getDefaultTreePatternBits</span><span class="result">: <span class="extype" name="org.apache.spark.util.collection.BitSet">BitSet</span></span>
      </span>
      
      <p class="shortcomment cmt">Default tree pattern <span class="extype" name="BitSet]">for a <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a>.
</span></p><div class="fullcomment"><div class="comment cmt"><p>Default tree pattern <span class="extype" name="BitSet]">for a <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a>.
</span></p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#getTagValue" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getTagValue[T](tag:org.apache.spark.sql.catalyst.trees.TreeNodeTag[T]):Option[T]"></a><a id="getTagValue[T](TreeNodeTag[T]):Option[T]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#getTagValue[T](tag:org.apache.spark.sql.catalyst.trees.TreeNodeTag[T]):Option[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getTagValue</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="tag">tag: <a href="../../trees/TreeNodeTag.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNodeTag">TreeNodeTag</a>[<span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.getTagValue.T">T</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.getTagValue.T">T</span>]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#hashCode" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#hashCode():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a> → AnyRef → Any</dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#hllppResults" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="hllppResults(buffer:Array[Long]):Array[Long]"></a><a id="hllppResults(Array[Long]):Array[Long]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#hllppResults(buffer:Array[Long]):Array[Long]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hllppResults</span><span class="params">(<span name="buffer">buffer: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      
      
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate#initialize" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="initialize(buffer:org.apache.spark.sql.catalyst.InternalRow):Unit"></a><a id="initialize(InternalRow):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#initialize(buffer:org.apache.spark.sql.catalyst.InternalRow):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">initialize</span><span class="params">(<span name="buffer">buffer: <a href="../../InternalRow.html" class="extype" name="org.apache.spark.sql.catalyst.InternalRow">InternalRow</a></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Initializes the mutable aggregation buffer located in <code>mutableAggBuffer</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Initializes the mutable aggregation buffer located in <code>mutableAggBuffer</code>.</p><p>Use <code>fieldNumber + mutableAggBufferOffset</code> to access fields of <code>mutableAggBuffer</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a> → <a href="ImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ImperativeAggregate">ImperativeAggregate</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#innerChildren" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="innerChildren:Seq[org.apache.spark.sql.catalyst.trees.TreeNode[_]]"></a><a id="innerChildren:Seq[TreeNode[_]]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#innerChildren:Seq[org.apache.spark.sql.catalyst.trees.TreeNode[_]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">innerChildren</span><span class="result">: <span class="extype" name="scala.Seq">Seq</span>[<a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a>[_]]</span>
      </span>
      
      <p class="shortcomment cmt">All the nodes that should be shown as a inner nested tree of this node.</p><div class="fullcomment"><div class="comment cmt"><p>All the nodes that should be shown as a inner nested tree of this node.
For example, this can be used to show sub-queries.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate#inputAggBufferAttributes" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="inputAggBufferAttributes:Seq[org.apache.spark.sql.catalyst.expressions.AttributeReference]"></a><a id="inputAggBufferAttributes:Seq[AttributeReference]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#inputAggBufferAttributes:Seq[org.apache.spark.sql.catalyst.expressions.AttributeReference]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">inputAggBufferAttributes</span><span class="result">: <span class="extype" name="scala.Seq">Seq</span>[<a href="../AttributeReference.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.AttributeReference">AttributeReference</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Attributes of fields in input aggregation buffers (immutable aggregation buffers that are
merged with mutable aggregation buffers in the merge() function or merge expressions).</p><div class="fullcomment"><div class="comment cmt"><p>Attributes of fields in input aggregation buffers (immutable aggregation buffers that are
merged with mutable aggregation buffers in the merge() function or merge expressions).
These attributes are created automatically by cloning the <a href="TypedImperativeAggregate.html#aggBufferAttributes:Seq[org.apache.spark.sql.catalyst.expressions.AttributeReference]" class="extmbr" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate#aggBufferAttributes">aggBufferAttributes</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a> → <a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#inputAggBufferOffset" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="inputAggBufferOffset:Int"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#inputAggBufferOffset:Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">inputAggBufferOffset</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <p class="shortcomment cmt">The offset of this function's start buffer value in the underlying shared input aggregation
buffer.</p><div class="fullcomment"><div class="comment cmt"><p>The offset of this function's start buffer value in the underlying shared input aggregation
buffer. An input aggregation buffer is used when we merge two aggregation buffers together in
the <code>update()</code> function and is immutable (we merge an input aggregation buffer and a mutable
aggregation buffer and then store the new buffer values to the mutable aggregation buffer).</p><p>An input aggregation buffer may contain extra fields, such as grouping keys, at its start, so
mutableAggBufferOffset and inputAggBufferOffset are often different.</p><p>For example, say we have a grouping expression, <code>key</code>, and two aggregate functions,
<code>avg(x)</code> and <code>avg(y)</code>. In the shared input aggregation buffer, the position of the first
buffer value of <code>avg(x)</code> will be 1 and the position of the first buffer value of <code>avg(y)</code>
will be 3 (position 0 is used for the value of <code>key</code>):</p><pre>avg(x) inputAggBufferOffset = <span class="num">1</span>
         |
         v
+--------+--------+--------+--------+--------+
|  key   |  sum1  | count1 |  sum2  | count2 |
+--------+--------+--------+--------+--------+
                           ^
                           |
             avg(y) inputAggBufferOffset = <span class="num">3</span></pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="ImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ImperativeAggregate">ImperativeAggregate</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#inputTypes" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="inputTypes:Seq[org.apache.spark.sql.types.AbstractDataType]"></a><a id="inputTypes:Seq[AbstractDataType]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#inputTypes:Seq[org.apache.spark.sql.types.AbstractDataType]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inputTypes</span><span class="result">: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="org.apache.spark.sql.types.AbstractDataType">AbstractDataType</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Expected input types from child expressions.</p><div class="fullcomment"><div class="comment cmt"><p>Expected input types from child expressions. The i-th position in the returned seq indicates
the type requirement for the i-th child.</p><p>The possible values at each position are:
1. a specific data type, e.g. LongType, StringType.
2. a non-leaf abstract data type, e.g. NumericType, IntegralType, FractionalType.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="../ExpectsInputTypes.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.ExpectsInputTypes">ExpectsInputTypes</a></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#isInstanceOf[T0]:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#isRuleIneffective" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isRuleIneffective(ruleId:org.apache.spark.sql.catalyst.rules.RuleId):Boolean"></a><a id="isRuleIneffective(RuleId):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#isRuleIneffective(ruleId:org.apache.spark.sql.catalyst.rules.RuleId):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isRuleIneffective</span><span class="params">(<span name="ruleId">ruleId: <a href="../../rules/RuleId.html" class="extype" name="org.apache.spark.sql.catalyst.rules.RuleId">RuleId</a></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <p class="shortcomment cmt">Whether this TreeNode and its subtree have been marked as ineffective for the rule with id
<code>ruleId</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Whether this TreeNode and its subtree have been marked as ineffective for the rule with id
<code>ruleId</code>.
</p></div><dl class="paramcmts block"><dt class="param">ruleId</dt><dd class="cmt"><p>the unique id of the rule</p></dd><dt>returns</dt><dd class="cmt"><p>true if the rule has been marked as ineffective; false otherwise. If <code>ruleId</code> is
        UnknownId, it returns false.</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#jsonFields" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="jsonFields:List[org.json4s.JsonAST.JField]"></a><a id="jsonFields:List[JField]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#jsonFields:List[org.json4s.JsonAST.JField]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">jsonFields</span><span class="result">: <span class="extype" name="scala.List">List</span>[<span class="extype" name="org.json4s.JsonAST.JField">JField</span>]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#left" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="left:org.apache.spark.sql.catalyst.expressions.Expression"></a><a id="left:Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#left:org.apache.spark.sql.catalyst.expressions.Expression" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">left</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="../../trees/BinaryLike.html" class="extype" name="org.apache.spark.sql.catalyst.trees.BinaryLike">BinaryLike</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#legacyWithNewChildren" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="legacyWithNewChildren(newChildren:Seq[BaseType]):BaseType"></a><a id="legacyWithNewChildren(Seq[Expression]):Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#legacyWithNewChildren(newChildren:Seq[BaseType]):BaseType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">legacyWithNewChildren</span><span class="params">(<span name="newChildren">newChildren: <span class="extype" name="scala.Seq">Seq</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>)</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this node with the children replaced.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a copy of this node with the children replaced.
TODO: Validate somewhere (in debug mode?) that children are ordered correctly.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#makeCopy" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="makeCopy(newArgs:Array[AnyRef]):BaseType"></a><a id="makeCopy(Array[AnyRef]):Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#makeCopy(newArgs:Array[AnyRef]):BaseType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">makeCopy</span><span class="params">(<span name="newArgs">newArgs: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.AnyRef">AnyRef</span>]</span>)</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <p class="shortcomment cmt">Creates a copy of this type of tree node after a transformation.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a copy of this type of tree node after a transformation.
Must be overridden by child classes that have constructor arguments
that are not present in the productIterator.</p></div><dl class="paramcmts block"><dt class="param">newArgs</dt><dd class="cmt"><p>the new product arguments.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#map" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="map[A](f:BaseType=&gt;A):Seq[A]"></a><a id="map[A]((Expression)⇒A):Seq[A]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#map[A](f:BaseType=&gt;A):Seq[A]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="f">f: (<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>) ⇒ <span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.map.A">A</span></span>)</span><span class="result">: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.map.A">A</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a Seq containing the result of applying the given function to each
node in this tree in a preorder traversal.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a Seq containing the result of applying the given function to each
node in this tree in a preorder traversal.</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to be applied.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.BinaryLike#mapChildren" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mapChildren(f:T=&gt;T):T"></a><a id="mapChildren((Expression)⇒Expression):Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#mapChildren(f:T=&gt;T):T" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mapChildren</span><span class="params">(<span name="f">f: (<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>) ⇒ <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>)</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/BinaryLike.html" class="extype" name="org.apache.spark.sql.catalyst.trees.BinaryLike">BinaryLike</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#mapProductIterator" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mapProductIterator[B](f:Any=&gt;B)(implicitevidence$1:scala.reflect.ClassTag[B]):Array[B]"></a><a id="mapProductIterator[B]((Any)⇒B)(ClassTag[B]):Array[B]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#mapProductIterator[B](f:Any=&gt;B)(implicitevidence$1:scala.reflect.ClassTag[B]):Array[B]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mapProductIterator</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.Any">Any</span>) ⇒ <span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.mapProductIterator.B">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span class="extype" name="scala.reflect.ClassTag">ClassTag</span>[<span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.mapProductIterator.B">B</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.mapProductIterator.B">B</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Efficient alternative to <code>productIterator.map(f).toArray</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Efficient alternative to <code>productIterator.map(f).toArray</code>.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#markRuleAsIneffective" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="markRuleAsIneffective(ruleId:org.apache.spark.sql.catalyst.rules.RuleId):Unit"></a><a id="markRuleAsIneffective(RuleId):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#markRuleAsIneffective(ruleId:org.apache.spark.sql.catalyst.rules.RuleId):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">markRuleAsIneffective</span><span class="params">(<span name="ruleId">ruleId: <a href="../../rules/RuleId.html" class="extype" name="org.apache.spark.sql.catalyst.rules.RuleId">RuleId</a></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Mark that a rule (with id <code>ruleId</code>) is ineffective for this TreeNode and its subtree.</p><div class="fullcomment"><div class="comment cmt"><p>Mark that a rule (with id <code>ruleId</code>) is ineffective for this TreeNode and its subtree.
</p></div><dl class="paramcmts block"><dt class="param">ruleId</dt><dd class="cmt"><p>the unique identifier of the rule. If <code>ruleId</code> is UnknownId, it is a no-op.</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#merge" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="merge(buffer1:Array[Long],buffer2:Array[Long]):Array[Long]"></a><a id="merge(Array[Long],Array[Long]):Array[Long]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#merge(buffer1:Array[Long],buffer2:Array[Long]):Array[Long]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">merge</span><span class="params">(<span name="buffer1">buffer1: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]</span>, <span name="buffer2">buffer2: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Merges an input aggregation object into aggregation buffer object and returns a new buffer
object.</p><div class="fullcomment"><div class="comment cmt"><p>Merges an input aggregation object into aggregation buffer object and returns a new buffer
object. For performance, the function may do in-place merge and return it instead of
constructing new buffer object.</p><p>This is typically called when doing PartialMerge or Final mode aggregation.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate#merge" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="merge(buffer:org.apache.spark.sql.catalyst.InternalRow,inputBuffer:org.apache.spark.sql.catalyst.InternalRow):Unit"></a><a id="merge(InternalRow,InternalRow):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#merge(buffer:org.apache.spark.sql.catalyst.InternalRow,inputBuffer:org.apache.spark.sql.catalyst.InternalRow):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">merge</span><span class="params">(<span name="buffer">buffer: <a href="../../InternalRow.html" class="extype" name="org.apache.spark.sql.catalyst.InternalRow">InternalRow</a></span>, <span name="inputBuffer">inputBuffer: <a href="../../InternalRow.html" class="extype" name="org.apache.spark.sql.catalyst.InternalRow">InternalRow</a></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Combines new intermediate results from the <code>inputAggBuffer</code> with the existing intermediate
results in the <code>mutableAggBuffer.</code></p><div class="fullcomment"><div class="comment cmt"><p>Combines new intermediate results from the <code>inputAggBuffer</code> with the existing intermediate
results in the <code>mutableAggBuffer.</code></p><p>Use <code>fieldNumber + mutableAggBufferOffset</code> to access fields of <code>mutableAggBuffer</code>.
Use <code>fieldNumber + inputAggBufferOffset</code> to access fields of <code>inputAggBuffer</code>.</p><p>Note that, the input row may be produced by unsafe projection and it may not be safe to cache
some fields of the input row, as the values can be changed unexpectedly.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a> → <a href="ImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ImperativeAggregate">ImperativeAggregate</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate#mergeBuffersObjects" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mergeBuffersObjects(buffer:org.apache.spark.sql.catalyst.InternalRow,inputBuffer:org.apache.spark.sql.catalyst.InternalRow):Unit"></a><a id="mergeBuffersObjects(InternalRow,InternalRow):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#mergeBuffersObjects(buffer:org.apache.spark.sql.catalyst.InternalRow,inputBuffer:org.apache.spark.sql.catalyst.InternalRow):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mergeBuffersObjects</span><span class="params">(<span name="buffer">buffer: <a href="../../InternalRow.html" class="extype" name="org.apache.spark.sql.catalyst.InternalRow">InternalRow</a></span>, <span name="inputBuffer">inputBuffer: <a href="../../InternalRow.html" class="extype" name="org.apache.spark.sql.catalyst.InternalRow">InternalRow</a></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Merge an input buffer into the aggregation buffer, where both buffers contain the deserialized
java object.</p><div class="fullcomment"><div class="comment cmt"><p>Merge an input buffer into the aggregation buffer, where both buffers contain the deserialized
java object. This function is used by aggregating accumulators.
</p></div><dl class="paramcmts block"><dt class="param">buffer</dt><dd class="cmt"><p>the aggregation buffer that is updated.</p></dd><dt class="param">inputBuffer</dt><dd class="cmt"><p>the buffer that is merged into the aggregation buffer.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#mutableAggBufferOffset" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mutableAggBufferOffset:Int"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#mutableAggBufferOffset:Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">mutableAggBufferOffset</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <p class="shortcomment cmt">The offset of this function's first buffer value in the underlying shared mutable aggregation
buffer.</p><div class="fullcomment"><div class="comment cmt"><p>The offset of this function's first buffer value in the underlying shared mutable aggregation
buffer.</p><p>For example, we have two aggregate functions <code>avg(x)</code> and <code>avg(y)</code>, which share the same
aggregation buffer. In this shared buffer, the position of the first buffer value of <code>avg(x)</code>
will be 0 and the position of the first buffer value of <code>avg(y)</code> will be 2:</p><pre>avg(x) mutableAggBufferOffset = <span class="num">0</span>
        |
        v
        +--------+--------+--------+--------+
        |  sum1  | count1 |  sum2  | count2 |
        +--------+--------+--------+--------+
                          ^
                          |
           avg(y) mutableAggBufferOffset = <span class="num">2</span></pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="ImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ImperativeAggregate">ImperativeAggregate</a></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#ne(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#nodeName" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nodeName:String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#nodeName:String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nodeName</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <p class="shortcomment cmt">Returns the name of this type of TreeNode.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the name of this type of TreeNode.  Defaults to the class name.
Note that we remove the &quot;Exec&quot; suffix for physical operators here.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#nodePatterns" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nodePatterns:Seq[org.apache.spark.sql.catalyst.trees.TreePattern.TreePattern]"></a><a id="nodePatterns:Seq[TreePattern]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#nodePatterns:Seq[org.apache.spark.sql.catalyst.trees.TreePattern.TreePattern]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">nodePatterns</span><span class="result">: <span class="extype" name="scala.Seq">Seq</span>[<a href="../../trees/TreePattern$.html#TreePattern=org.apache.spark.sql.catalyst.trees.TreePattern.Value" class="extmbr" name="org.apache.spark.sql.catalyst.trees.TreePattern.TreePattern">TreePattern</a>]</span>
      </span>
      
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a sequence of tree pattern enums in a TreeNode T. It does not include propagated
        patterns in the subtree of T.</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#notify():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#notifyAll():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#nullable" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nullable:Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#nullable:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nullable</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#numberedTreeString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="numberedTreeString:String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#numberedTreeString:String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">numberedTreeString</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <p class="shortcomment cmt">Returns a string representation of the nodes in this tree, where each operator is numbered.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a string representation of the nodes in this tree, where each operator is numbered.
The numbers can be used with <a href="../../trees/TreeNode.html#apply(number:Int):org.apache.spark.sql.catalyst.trees.TreeNode[_]" class="extmbr" name="org.apache.spark.sql.catalyst.trees.TreeNode#apply">TreeNode.apply</a> to easily access specific subtrees.</p><p>The numbers are based on depth-first traversal of the tree (with innerChildren traversed first
before children).
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#origin" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="origin:org.apache.spark.sql.catalyst.trees.Origin"></a><a id="origin:Origin"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#origin:org.apache.spark.sql.catalyst.trees.Origin" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">origin</span><span class="result">: <a href="../../trees/Origin.html" class="extype" name="org.apache.spark.sql.catalyst.trees.Origin">Origin</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#otherCopyArgs" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="otherCopyArgs:Seq[AnyRef]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#otherCopyArgs:Seq[AnyRef]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">otherCopyArgs</span><span class="result">: <span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="scala.AnyRef">AnyRef</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Args to the constructor that should be copied, but not transformed.</p><div class="fullcomment"><div class="comment cmt"><p>Args to the constructor that should be copied, but not transformed.
These are appended to the transformed args automatically by makeCopy</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#p" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="p(number:Int):BaseType"></a><a id="p(Int):Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#p(number:Int):BaseType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">p</span><span class="params">(<span name="number">number: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns the tree node at the specified number, used primarily for interactive debugging.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the tree node at the specified number, used primarily for interactive debugging.
Numbers for each node can be found in the <a href="../../trees/TreeNode.html#numberedTreeString:String" class="extmbr" name="org.apache.spark.sql.catalyst.trees.TreeNode#numberedTreeString">numberedTreeString</a>.</p><p>This is a variant of <a href="../../trees/TreeNode.html#apply(number:Int):org.apache.spark.sql.catalyst.trees.TreeNode[_]" class="extmbr" name="org.apache.spark.sql.catalyst.trees.TreeNode#apply">apply</a> that returns the node as BaseType (if the type matches).
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#prettyJson" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prettyJson:String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#prettyJson:String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prettyJson</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#prettyName" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prettyName:String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#prettyName:String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prettyName</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <p class="shortcomment cmt">Returns a user-facing string representation of this expression's name.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a user-facing string representation of this expression's name.
This should usually match the name of the function in SQL.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#references" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="references:org.apache.spark.sql.catalyst.expressions.AttributeSet"></a><a id="references:AttributeSet"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#references:org.apache.spark.sql.catalyst.expressions.AttributeSet" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">references</span><span class="result">: <a href="../AttributeSet.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.AttributeSet">AttributeSet</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#relativeSD" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="relativeSD:Double"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#relativeSD:Double" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">relativeSD</span><span class="result">: <span class="extype" name="scala.Double">Double</span></span>
      </span>
      
      
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#resolved" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="resolved:Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#resolved:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">resolved</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <p class="shortcomment cmt">Returns <code>true</code> if this expression and all its children have been resolved to a specific schema
and input data types checking passed, and <code>false</code> if it still contains any unresolved
placeholders or has data types mismatch.</p><div class="fullcomment"><div class="comment cmt"><p>Returns <code>true</code> if this expression and all its children have been resolved to a specific schema
and input data types checking passed, and <code>false</code> if it still contains any unresolved
placeholders or has data types mismatch.
Implementations of expressions should override this if the resolution of this type of
expression involves more than just the resolution of its children and type checking.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#right" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="right:org.apache.spark.sql.catalyst.expressions.Expression"></a><a id="right:Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#right:org.apache.spark.sql.catalyst.expressions.Expression" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">right</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="../../trees/BinaryLike.html" class="extype" name="org.apache.spark.sql.catalyst.trees.BinaryLike">BinaryLike</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#semanticEquals" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="semanticEquals(other:org.apache.spark.sql.catalyst.expressions.Expression):Boolean"></a><a id="semanticEquals(Expression):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#semanticEquals(other:org.apache.spark.sql.catalyst.expressions.Expression):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">semanticEquals</span><span class="params">(<span name="other">other: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <p class="shortcomment cmt">Returns true when two expressions will always compute the same result, even if they differ
cosmetically (i.e.</p><div class="fullcomment"><div class="comment cmt"><p>Returns true when two expressions will always compute the same result, even if they differ
cosmetically (i.e. capitalization of names in attributes may be different).</p><p>See <a href="../Canonicalize$.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Canonicalize">Canonicalize</a> for more details.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#semanticHash" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="semanticHash():Int"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#semanticHash():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">semanticHash</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <p class="shortcomment cmt">Returns a <code>hashCode</code> for the calculation performed by this expression.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>hashCode</code> for the calculation performed by this expression. Unlike the standard
<code>hashCode</code>, an attempt has been made to eliminate cosmetic differences.</p><p>See <a href="../Canonicalize$.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Canonicalize">Canonicalize</a> for more details.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#serialize" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="serialize(obj:Array[Long]):Array[Byte]"></a><a id="serialize(Array[Long]):Array[Byte]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#serialize(obj:Array[Long]):Array[Byte]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">serialize</span><span class="params">(<span name="obj">obj: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Serializes the aggregation buffer object T to Array[Byte]</p><div class="fullcomment"><div class="comment cmt"><p>Serializes the aggregation buffer object T to Array[Byte]</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate#serializeAggregateBufferInPlace" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="serializeAggregateBufferInPlace(buffer:org.apache.spark.sql.catalyst.InternalRow):Unit"></a><a id="serializeAggregateBufferInPlace(InternalRow):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#serializeAggregateBufferInPlace(buffer:org.apache.spark.sql.catalyst.InternalRow):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">serializeAggregateBufferInPlace</span><span class="params">(<span name="buffer">buffer: <a href="../../InternalRow.html" class="extype" name="org.apache.spark.sql.catalyst.InternalRow">InternalRow</a></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">In-place replaces the aggregation buffer object stored at buffer's index
<code>mutableAggBufferOffset</code>, with SparkSQL internally supported underlying storage format
(BinaryType).</p><div class="fullcomment"><div class="comment cmt"><p>In-place replaces the aggregation buffer object stored at buffer's index
<code>mutableAggBufferOffset</code>, with SparkSQL internally supported underlying storage format
(BinaryType).</p><p>This is only called when doing Partial or PartialMerge mode aggregation, before the framework
shuffle out aggregate buffers.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#setTagValue" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="setTagValue[T](tag:org.apache.spark.sql.catalyst.trees.TreeNodeTag[T],value:T):Unit"></a><a id="setTagValue[T](TreeNodeTag[T],T):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#setTagValue[T](tag:org.apache.spark.sql.catalyst.trees.TreeNodeTag[T],value:T):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">setTagValue</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="tag">tag: <a href="../../trees/TreeNodeTag.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNodeTag">TreeNodeTag</a>[<span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.setTagValue.T">T</span>]</span>, <span name="value">value: <span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.setTagValue.T">T</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#simpleString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="simpleString(maxFields:Int):String"></a><a id="simpleString(Int):String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#simpleString(maxFields:Int):String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">simpleString</span><span class="params">(<span name="maxFields">maxFields: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <p class="shortcomment cmt">ONE line description of this node.</p><div class="fullcomment"><div class="comment cmt"><p>ONE line description of this node.</p></div><dl class="paramcmts block"><dt class="param">maxFields</dt><dd class="cmt"><p>Maximum number of fields that will be converted to strings.
                 Any elements beyond the limit will be dropped.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a> → <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#simpleStringWithNodeId" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="simpleStringWithNodeId():String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#simpleStringWithNodeId():String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">simpleStringWithNodeId</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <p class="shortcomment cmt">ONE line description of this node containing the node identifier.</p><div class="fullcomment"><div class="comment cmt"><p>ONE line description of this node containing the node identifier.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a> → <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction#sql" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sql(isDistinct:Boolean):String"></a><a id="sql(Boolean):String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#sql(isDistinct:Boolean):String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sql</span><span class="params">(<span name="isDistinct">isDistinct: <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#sql" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sql:String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#sql:String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sql</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <p class="shortcomment cmt">Returns SQL representation of this expression.</p><div class="fullcomment"><div class="comment cmt"><p>Returns SQL representation of this expression.  For expressions extending <a href="../NonSQLExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.NonSQLExpression">NonSQLExpression</a>,
this method may return an arbitrary user facing string.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#stringArgs" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="stringArgs:Iterator[Any]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#stringArgs:Iterator[Any]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">stringArgs</span><span class="result">: <span class="extype" name="scala.Iterator">Iterator</span>[<span class="extype" name="scala.Any">Any</span>]</span>
      </span>
      
      <p class="shortcomment cmt">The arguments that should be included in the arg string.</p><div class="fullcomment"><div class="comment cmt"><p>The arguments that should be included in the arg string.  Defaults to the <code>productIterator</code>.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](⇒T0):T0"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction#toAggString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toAggString(isDistinct:Boolean):String"></a><a id="toAggString(Boolean):String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#toAggString(isDistinct:Boolean):String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toAggString</span><span class="params">(<span name="isDistinct">isDistinct: <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <p class="shortcomment cmt">String representation used in explain plans.</p><div class="fullcomment"><div class="comment cmt"><p>String representation used in explain plans.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction#toAggregateExpression" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toAggregateExpression(isDistinct:Boolean,filter:Option[org.apache.spark.sql.catalyst.expressions.Expression]):org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression"></a><a id="toAggregateExpression(Boolean,Option[Expression]):AggregateExpression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#toAggregateExpression(isDistinct:Boolean,filter:Option[org.apache.spark.sql.catalyst.expressions.Expression]):org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toAggregateExpression</span><span class="params">(<span name="isDistinct">isDistinct: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="filter">filter: <span class="extype" name="scala.Option">Option</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>] = <span class="symbol">None</span></span>)</span><span class="result">: <a href="AggregateExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression">AggregateExpression</a></span>
      </span>
      
      <p class="shortcomment cmt">Wraps this <a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a> in an <a href="AggregateExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression">AggregateExpression</a> and sets <code>isDistinct</code>
flag of the <a href="AggregateExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression">AggregateExpression</a> to the given value because
<a href="AggregateExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression">AggregateExpression</a> is the container of an <a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a>, aggregation mode,
and the flag indicating if this aggregation is distinct aggregation or not.</p><div class="fullcomment"><div class="comment cmt"><p>Wraps this <a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a> in an <a href="AggregateExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression">AggregateExpression</a> and sets <code>isDistinct</code>
flag of the <a href="AggregateExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression">AggregateExpression</a> to the given value because
<a href="AggregateExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression">AggregateExpression</a> is the container of an <a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a>, aggregation mode,
and the flag indicating if this aggregation is distinct aggregation or not.
An <a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a> should not be used without being wrapped in
an <a href="AggregateExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression">AggregateExpression</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction#toAggregateExpression" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toAggregateExpression():org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression"></a><a id="toAggregateExpression():AggregateExpression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#toAggregateExpression():org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toAggregateExpression</span><span class="params">()</span><span class="result">: <a href="AggregateExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression">AggregateExpression</a></span>
      </span>
      
      <p class="shortcomment cmt">Creates <a href="AggregateExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression">AggregateExpression</a> with <code>isDistinct</code> flag disabled.</p><div class="fullcomment"><div class="comment cmt"><p>Creates <a href="AggregateExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression">AggregateExpression</a> with <code>isDistinct</code> flag disabled.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a></dd><dt>See also</dt><dd><span class="cmt"><p><code>toAggregateExpression(isDistinct: Boolean)</code> for detailed description</p></span></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#toJSON" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toJSON:String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#toJSON:String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toJSON</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#toString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#toString():String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a> → <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a> → AnyRef → Any</dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#transform" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transform(rule:PartialFunction[BaseType,BaseType]):BaseType"></a><a id="transform(PartialFunction[Expression,Expression]):Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#transform(rule:PartialFunction[BaseType,BaseType]):BaseType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transform</span><span class="params">(<span name="rule">rule: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>, <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>)</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this node where <code>rule</code> has been recursively applied to the tree.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a copy of this node where <code>rule</code> has been recursively applied to the tree.
When <code>rule</code> does not apply to a given node it is left unchanged.
Users should not expect a specific directionality. If a specific directionality is needed,
transformDown or transformUp should be used.
</p></div><dl class="paramcmts block"><dt class="param">rule</dt><dd class="cmt"><p>the function used to transform this nodes children</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#transformDown" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transformDown(rule:PartialFunction[BaseType,BaseType]):BaseType"></a><a id="transformDown(PartialFunction[Expression,Expression]):Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#transformDown(rule:PartialFunction[BaseType,BaseType]):BaseType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transformDown</span><span class="params">(<span name="rule">rule: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>, <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>)</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this node where <code>rule</code> has been recursively applied to it and all of its
children (pre-order).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a copy of this node where <code>rule</code> has been recursively applied to it and all of its
children (pre-order). When <code>rule</code> does not apply to a given node it is left unchanged.
</p></div><dl class="paramcmts block"><dt class="param">rule</dt><dd class="cmt"><p>the function used to transform this nodes children</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#transformDownWithPruning" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transformDownWithPruning(cond:org.apache.spark.sql.catalyst.trees.TreePatternBits=&gt;Boolean,ruleId:org.apache.spark.sql.catalyst.rules.RuleId)(rule:PartialFunction[BaseType,BaseType]):BaseType"></a><a id="transformDownWithPruning((TreePatternBits)⇒Boolean,RuleId)(PartialFunction[Expression,Expression]):Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#transformDownWithPruning(cond:org.apache.spark.sql.catalyst.trees.TreePatternBits=&gt;Boolean,ruleId:org.apache.spark.sql.catalyst.rules.RuleId)(rule:PartialFunction[BaseType,BaseType]):BaseType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transformDownWithPruning</span><span class="params">(<span name="cond">cond: (<a href="../../trees/TreePatternBits.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreePatternBits">TreePatternBits</a>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="ruleId">ruleId: <a href="../../rules/RuleId.html" class="extype" name="org.apache.spark.sql.catalyst.rules.RuleId">RuleId</a> = <span class="symbol"><span class="name"><a href="../../../../../../index.html">UnknownRuleId</a></span></span></span>)</span><span class="params">(<span name="rule">rule: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>, <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>)</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this node where <code>rule</code> has been recursively applied to it and all of its
children (pre-order).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a copy of this node where <code>rule</code> has been recursively applied to it and all of its
children (pre-order). When <code>rule</code> does not apply to a given node it is left unchanged.
</p></div><dl class="paramcmts block"><dt class="param">cond</dt><dd class="cmt"><p>a Lambda expression to prune tree traversals. If <code>cond.apply</code> returns false
              on a TreeNode T, skips processing T and its subtree; otherwise, processes
              T and its subtree recursively.</p></dd><dt class="param">ruleId</dt><dd class="cmt"><p>is a unique Id for <code>rule</code> to prune unnecessary tree traversals. When it is
              UnknownRuleId, no pruning happens. Otherwise, if <code>rule</code> (with id <code>ruleId</code>)
              has been marked as in effective on a TreeNode T, skips processing T and its
              subtree. Do not pass it if the rule is not purely functional and reads a
              varying initial state for different invocations.</p></dd><dt class="param">rule</dt><dd class="cmt"><p>the function used to transform this nodes children</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#transformUp" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transformUp(rule:PartialFunction[BaseType,BaseType]):BaseType"></a><a id="transformUp(PartialFunction[Expression,Expression]):Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#transformUp(rule:PartialFunction[BaseType,BaseType]):BaseType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transformUp</span><span class="params">(<span name="rule">rule: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>, <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>)</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this node where <code>rule</code> has been recursively applied first to all of its
children and then itself (post-order).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a copy of this node where <code>rule</code> has been recursively applied first to all of its
children and then itself (post-order). When <code>rule</code> does not apply to a given node, it is left
unchanged.
</p></div><dl class="paramcmts block"><dt class="param">rule</dt><dd class="cmt"><p>the function used to transform this nodes children</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#transformUpWithBeforeAndAfterRuleOnChildren" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transformUpWithBeforeAndAfterRuleOnChildren(cond:BaseType=&gt;Boolean,ruleId:org.apache.spark.sql.catalyst.rules.RuleId)(rule:PartialFunction[(BaseType,BaseType),BaseType]):BaseType"></a><a id="transformUpWithBeforeAndAfterRuleOnChildren((Expression)⇒Boolean,RuleId)(PartialFunction[(Expression,Expression),Expression]):Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#transformUpWithBeforeAndAfterRuleOnChildren(cond:BaseType=&gt;Boolean,ruleId:org.apache.spark.sql.catalyst.rules.RuleId)(rule:PartialFunction[(BaseType,BaseType),BaseType]):BaseType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transformUpWithBeforeAndAfterRuleOnChildren</span><span class="params">(<span name="cond">cond: (<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="ruleId">ruleId: <a href="../../rules/RuleId.html" class="extype" name="org.apache.spark.sql.catalyst.rules.RuleId">RuleId</a> = <span class="symbol"><span class="name"><a href="../../../../../../index.html">UnknownRuleId</a></span></span></span>)</span><span class="params">(<span name="rule">rule: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[(<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>, <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>), <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>)</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this node where <code>rule</code> has been recursively applied first to all of its
children and then itself (post-order).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a copy of this node where <code>rule</code> has been recursively applied first to all of its
children and then itself (post-order). When <code>rule</code> does not apply to a given node, it is left
unchanged.
</p></div><dl class="paramcmts block"><dt class="param">cond</dt><dd class="cmt"><p>a Lambda expression to prune tree traversals. If <code>cond.apply</code> returns false
              on a TreeNode T, skips processing T and its subtree; otherwise, processes
              T and its subtree recursively.</p></dd><dt class="param">ruleId</dt><dd class="cmt"><p>is a unique Id for <code>rule</code> to prune unnecessary tree traversals. When it is
              UnknownRuleId, no pruning happens. Otherwise, if <code>rule</code> (with id <code>ruleId</code>)
              has been marked as in effective on a TreeNode T, skips processing T and its
              subtree. Do not pass it if the rule is not purely functional and reads a
              varying initial state for different invocations.</p></dd><dt class="param">rule</dt><dd class="cmt"><p>the function use to transform this node and its descendant nodes. The function
              takes a tuple as its input, where the first/second field is the before/after
              image of applying the rule on the node's children.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#transformUpWithPruning" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transformUpWithPruning(cond:org.apache.spark.sql.catalyst.trees.TreePatternBits=&gt;Boolean,ruleId:org.apache.spark.sql.catalyst.rules.RuleId)(rule:PartialFunction[BaseType,BaseType]):BaseType"></a><a id="transformUpWithPruning((TreePatternBits)⇒Boolean,RuleId)(PartialFunction[Expression,Expression]):Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#transformUpWithPruning(cond:org.apache.spark.sql.catalyst.trees.TreePatternBits=&gt;Boolean,ruleId:org.apache.spark.sql.catalyst.rules.RuleId)(rule:PartialFunction[BaseType,BaseType]):BaseType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transformUpWithPruning</span><span class="params">(<span name="cond">cond: (<a href="../../trees/TreePatternBits.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreePatternBits">TreePatternBits</a>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="ruleId">ruleId: <a href="../../rules/RuleId.html" class="extype" name="org.apache.spark.sql.catalyst.rules.RuleId">RuleId</a> = <span class="symbol"><span class="name"><a href="../../../../../../index.html">UnknownRuleId</a></span></span></span>)</span><span class="params">(<span name="rule">rule: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>, <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>)</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this node where <code>rule</code> has been recursively applied first to all of its
children and then itself (post-order).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a copy of this node where <code>rule</code> has been recursively applied first to all of its
children and then itself (post-order). When <code>rule</code> does not apply to a given node, it is left
unchanged.
</p></div><dl class="paramcmts block"><dt class="param">cond</dt><dd class="cmt"><p>a Lambda expression to prune tree traversals. If <code>cond.apply</code> returns false
              on a TreeNode T, skips processing T and its subtree; otherwise, processes
              T and its subtree recursively.</p></dd><dt class="param">ruleId</dt><dd class="cmt"><p>is a unique Id for <code>rule</code> to prune unnecessary tree traversals. When it is
              UnknownRuleId, no pruning happens. Otherwise, if <code>rule</code> (with id <code>ruleId</code>)
              has been marked as in effective on a TreeNode T, skips processing T and its
              subtree. Do not pass it if the rule is not purely functional and reads a
              varying initial state for different invocations.</p></dd><dt class="param">rule</dt><dd class="cmt"><p>the function used to transform this nodes children</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#transformWithPruning" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transformWithPruning(cond:org.apache.spark.sql.catalyst.trees.TreePatternBits=&gt;Boolean,ruleId:org.apache.spark.sql.catalyst.rules.RuleId)(rule:PartialFunction[BaseType,BaseType]):BaseType"></a><a id="transformWithPruning((TreePatternBits)⇒Boolean,RuleId)(PartialFunction[Expression,Expression]):Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#transformWithPruning(cond:org.apache.spark.sql.catalyst.trees.TreePatternBits=&gt;Boolean,ruleId:org.apache.spark.sql.catalyst.rules.RuleId)(rule:PartialFunction[BaseType,BaseType]):BaseType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transformWithPruning</span><span class="params">(<span name="cond">cond: (<a href="../../trees/TreePatternBits.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreePatternBits">TreePatternBits</a>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="ruleId">ruleId: <a href="../../rules/RuleId.html" class="extype" name="org.apache.spark.sql.catalyst.rules.RuleId">RuleId</a> = <span class="symbol"><span class="name"><a href="../../../../../../index.html">UnknownRuleId</a></span></span></span>)</span><span class="params">(<span name="rule">rule: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>, <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>)</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this node where <code>rule</code> has been recursively applied to the tree.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a copy of this node where <code>rule</code> has been recursively applied to the tree.
When <code>rule</code> does not apply to a given node it is left unchanged.
Users should not expect a specific directionality. If a specific directionality is needed,
transformDown or transformUp should be used.
</p></div><dl class="paramcmts block"><dt class="param">cond</dt><dd class="cmt"><p>a Lambda expression to prune tree traversals. If <code>cond.apply</code> returns false
              on a TreeNode T, skips processing T and its subtree; otherwise, processes
              T and its subtree recursively.</p></dd><dt class="param">ruleId</dt><dd class="cmt"><p>is a unique Id for <code>rule</code> to prune unnecessary tree traversals. When it is
              UnknownRuleId, no pruning happens. Otherwise, if <code>rule</code> (with id <code>ruleId</code>)
              has been marked as in effective on a TreeNode T, skips processing T and its
              subtree. Do not pass it if the rule is not purely functional and reads a
              varying initial state for different invocations.</p></dd><dt class="param">rule</dt><dd class="cmt"><p>the function used to transform this nodes children</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#treePatternBits" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="treePatternBits:org.apache.spark.util.collection.BitSet"></a><a id="treePatternBits:BitSet"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#treePatternBits:org.apache.spark.util.collection.BitSet" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">treePatternBits</span><span class="result">: <span class="extype" name="org.apache.spark.util.collection.BitSet">BitSet</span></span>
      </span>
      
      <p class="shortcomment cmt">A BitSet of tree patterns for this TreeNode and its subtree.</p><div class="fullcomment"><div class="comment cmt"><p>A BitSet of tree patterns for this TreeNode and its subtree. If this TreeNode and its
subtree contains a pattern <code>P</code>, the corresponding bit for <code>P.id</code> is set in this BitSet.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a> → <a href="../../trees/TreePatternBits.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreePatternBits">TreePatternBits</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#treeString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="treeString(append:String=&gt;Unit,verbose:Boolean,addSuffix:Boolean,maxFields:Int,printOperatorId:Boolean):Unit"></a><a id="treeString((String)⇒Unit,Boolean,Boolean,Int,Boolean):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#treeString(append:String=&gt;Unit,verbose:Boolean,addSuffix:Boolean,maxFields:Int,printOperatorId:Boolean):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">treeString</span><span class="params">(<span name="append">append: (<span class="extype" name="scala.Predef.String">String</span>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>, <span name="verbose">verbose: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="addSuffix">addSuffix: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="maxFields">maxFields: <span class="extype" name="scala.Int">Int</span></span>, <span name="printOperatorId">printOperatorId: <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#treeString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="treeString(verbose:Boolean,addSuffix:Boolean,maxFields:Int,printOperatorId:Boolean):String"></a><a id="treeString(Boolean,Boolean,Int,Boolean):String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#treeString(verbose:Boolean,addSuffix:Boolean,maxFields:Int,printOperatorId:Boolean):String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">treeString</span><span class="params">(<span name="verbose">verbose: <span class="extype" name="scala.Boolean">Boolean</span></span>, <span name="addSuffix">addSuffix: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="maxFields">maxFields: <span class="extype" name="scala.Int">Int</span> = <span class="symbol"><span class="name"><a href="../../../../../../index.html">SQLConf.get.maxToStringFields</a></span></span></span>, <span name="printOperatorId">printOperatorId: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#treeString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="treeString:String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#treeString:String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">treeString</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <p class="shortcomment cmt">Returns a string representation of the nodes in this tree</p><div class="fullcomment"><div class="comment cmt"><p>Returns a string representation of the nodes in this tree</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#unsetTagValue" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unsetTagValue[T](tag:org.apache.spark.sql.catalyst.trees.TreeNodeTag[T]):Unit"></a><a id="unsetTagValue[T](TreeNodeTag[T]):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#unsetTagValue[T](tag:org.apache.spark.sql.catalyst.trees.TreeNodeTag[T]):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unsetTagValue</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="tag">tag: <a href="../../trees/TreeNodeTag.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNodeTag">TreeNodeTag</a>[<span class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode.unsetTagValue.T">T</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#update" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="update(buffer:Array[Long],input:org.apache.spark.sql.catalyst.InternalRow):Array[Long]"></a><a id="update(Array[Long],InternalRow):Array[Long]"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#update(buffer:Array[Long],input:org.apache.spark.sql.catalyst.InternalRow):Array[Long]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">update</span><span class="params">(<span name="buffer">buffer: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]</span>, <span name="input">input: <a href="../../InternalRow.html" class="extype" name="org.apache.spark.sql.catalyst.InternalRow">InternalRow</a></span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Updates the aggregation buffer object with an input row and returns a new buffer object.</p><div class="fullcomment"><div class="comment cmt"><p>Updates the aggregation buffer object with an input row and returns a new buffer object. For
performance, the function may do in-place update and return it instead of constructing new
buffer object.</p><p>This is typically called when doing Partial or Complete mode aggregation.
</p></div><dl class="paramcmts block"><dt class="param">buffer</dt><dd class="cmt"><p>The aggregation buffer object.</p></dd><dt class="param">input</dt><dd class="cmt"><p>an input row</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate#update" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="update(buffer:org.apache.spark.sql.catalyst.InternalRow,input:org.apache.spark.sql.catalyst.InternalRow):Unit"></a><a id="update(InternalRow,InternalRow):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#update(buffer:org.apache.spark.sql.catalyst.InternalRow,input:org.apache.spark.sql.catalyst.InternalRow):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">update</span><span class="params">(<span name="buffer">buffer: <a href="../../InternalRow.html" class="extype" name="org.apache.spark.sql.catalyst.InternalRow">InternalRow</a></span>, <span name="input">input: <a href="../../InternalRow.html" class="extype" name="org.apache.spark.sql.catalyst.InternalRow">InternalRow</a></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Updates its aggregation buffer, located in <code>mutableAggBuffer</code>, based on the given <code>inputRow</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Updates its aggregation buffer, located in <code>mutableAggBuffer</code>, based on the given <code>inputRow</code>.</p><p>Use <code>fieldNumber + mutableAggBufferOffset</code> to access fields of <code>mutableAggBuffer</code>.</p><p>Note that, the input row may be produced by unsafe projection and it may not be safe to cache
some fields of the input row, as the values can be changed unexpectedly.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a> → <a href="ImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ImperativeAggregate">ImperativeAggregate</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.Expression#verboseString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="verboseString(maxFields:Int):String"></a><a id="verboseString(Int):String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#verboseString(maxFields:Int):String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">verboseString</span><span class="params">(<span name="maxFields">maxFields: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <p class="shortcomment cmt">ONE line description of this node with more information</p><div class="fullcomment"><div class="comment cmt"><p>ONE line description of this node with more information</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a> → <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#verboseStringWithSuffix" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="verboseStringWithSuffix(maxFields:Int):String"></a><a id="verboseStringWithSuffix(Int):String"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#verboseStringWithSuffix(maxFields:Int):String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">verboseStringWithSuffix</span><span class="params">(<span name="maxFields">maxFields: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      
      <p class="shortcomment cmt">ONE line description of this node with some suffix information</p><div class="fullcomment"><div class="comment cmt"><p>ONE line description of this node with some suffix information</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#wait():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#wait(x$1:Long):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.TreeNode#withNewChildren" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withNewChildren(newChildren:Seq[BaseType]):BaseType"></a><a id="withNewChildren(Seq[Expression]):Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#withNewChildren(newChildren:Seq[BaseType]):BaseType" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withNewChildren</span><span class="params">(<span name="newChildren">newChildren: <span class="extype" name="scala.Seq">Seq</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>)</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#withNewChildrenInternal" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withNewChildrenInternal(newLeft:org.apache.spark.sql.catalyst.expressions.Expression,newRight:org.apache.spark.sql.catalyst.expressions.Expression):org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals"></a><a id="withNewChildrenInternal(Expression,Expression):ApproxCountDistinctForIntervals"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#withNewChildrenInternal(newLeft:org.apache.spark.sql.catalyst.expressions.Expression,newRight:org.apache.spark.sql.catalyst.expressions.Expression):org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withNewChildrenInternal</span><span class="params">(<span name="newLeft">newLeft: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>, <span name="newRight">newRight: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>)</span><span class="result">: <a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="../../trees/BinaryLike.html" class="extype" name="org.apache.spark.sql.catalyst.trees.BinaryLike">BinaryLike</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees.BinaryLike#withNewChildrenInternal" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withNewChildrenInternal(newChildren:IndexedSeq[T]):T"></a><a id="withNewChildrenInternal(IndexedSeq[Expression]):Expression"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#withNewChildrenInternal(newChildren:IndexedSeq[T]):T" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withNewChildrenInternal</span><span class="params">(<span name="newChildren">newChildren: <span class="extype" name="scala.IndexedSeq">IndexedSeq</span>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>)</span><span class="result">: <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../trees/BinaryLike.html" class="extype" name="org.apache.spark.sql.catalyst.trees.BinaryLike">BinaryLike</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#withNewInputAggBufferOffset" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withNewInputAggBufferOffset(newInputAggBufferOffset:Int):org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals"></a><a id="withNewInputAggBufferOffset(Int):ApproxCountDistinctForIntervals"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#withNewInputAggBufferOffset(newInputAggBufferOffset:Int):org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withNewInputAggBufferOffset</span><span class="params">(<span name="newInputAggBufferOffset">newInputAggBufferOffset: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this ImperativeAggregate with an updated mutableAggBufferOffset.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a copy of this ImperativeAggregate with an updated mutableAggBufferOffset.
This new copy's attributes may have different ids than the original.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="ImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ImperativeAggregate">ImperativeAggregate</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals#withNewMutableAggBufferOffset" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withNewMutableAggBufferOffset(newMutableAggBufferOffset:Int):org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals"></a><a id="withNewMutableAggBufferOffset(Int):ApproxCountDistinctForIntervals"></a>
      <span class="permalink">
      <a href="../../../../../../../org/apache/spark/sql/catalyst/expressions/aggregate/ApproxCountDistinctForIntervals.html#withNewMutableAggBufferOffset(newMutableAggBufferOffset:Int):org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withNewMutableAggBufferOffset</span><span class="params">(<span name="newMutableAggBufferOffset">newMutableAggBufferOffset: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a></span>
      </span>
      
      <p class="shortcomment cmt">Returns a copy of this ImperativeAggregate with an updated mutableAggBufferOffset.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a copy of this ImperativeAggregate with an updated mutableAggBufferOffset.
This new copy's attributes may have different ids than the original.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ApproxCountDistinctForIntervals">ApproxCountDistinctForIntervals</a> → <a href="ImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ImperativeAggregate">ImperativeAggregate</a></dd></dl></div>
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.Serializable">
              <h3>Inherited from <span class="extype" name="scala.Serializable">Serializable</span></h3>
            </div><div class="parent" name="java.io.Serializable">
              <h3>Inherited from <span class="extype" name="java.io.Serializable">Serializable</span></h3>
            </div><div class="parent" name="org.apache.spark.sql.catalyst.trees.BinaryLike">
              <h3>Inherited from <a href="../../trees/BinaryLike.html" class="extype" name="org.apache.spark.sql.catalyst.trees.BinaryLike">BinaryLike</a>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</h3>
            </div><div class="parent" name="org.apache.spark.sql.catalyst.expressions.ExpectsInputTypes">
              <h3>Inherited from <a href="../ExpectsInputTypes.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.ExpectsInputTypes">ExpectsInputTypes</a></h3>
            </div><div class="parent" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">
              <h3>Inherited from <a href="TypedImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.TypedImperativeAggregate">TypedImperativeAggregate</a>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Long">Long</span>]]</h3>
            </div><div class="parent" name="org.apache.spark.sql.catalyst.expressions.aggregate.ImperativeAggregate">
              <h3>Inherited from <a href="ImperativeAggregate.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.ImperativeAggregate">ImperativeAggregate</a></h3>
            </div><div class="parent" name="org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback">
              <h3>Inherited from <a href="../codegen/CodegenFallback.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback">CodegenFallback</a></h3>
            </div><div class="parent" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">
              <h3>Inherited from <a href="AggregateFunction.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction">AggregateFunction</a></h3>
            </div><div class="parent" name="org.apache.spark.sql.catalyst.expressions.Expression">
              <h3>Inherited from <a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></h3>
            </div><div class="parent" name="org.apache.spark.sql.catalyst.trees.TreeNode">
              <h3>Inherited from <a href="../../trees/TreeNode.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreeNode">TreeNode</a>[<a href="../Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</h3>
            </div><div class="parent" name="org.apache.spark.sql.catalyst.trees.TreePatternBits">
              <h3>Inherited from <a href="../../trees/TreePatternBits.html" class="extype" name="org.apache.spark.sql.catalyst.trees.TreePatternBits">TreePatternBits</a></h3>
            </div><div class="parent" name="scala.Product">
              <h3>Inherited from <span class="extype" name="scala.Product">scala.Product</span></h3>
            </div><div class="parent" name="scala.Equals">
              <h3>Inherited from <span class="extype" name="scala.Equals">Equals</span></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
