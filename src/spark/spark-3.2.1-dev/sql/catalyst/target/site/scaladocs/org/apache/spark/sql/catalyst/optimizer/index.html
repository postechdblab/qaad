<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title>Spark Project Catalyst 3.2.1 API  - org.apache.spark.sql.catalyst.optimizer</title>
          <meta name="description" content="Spark Project Catalyst 3.2.1 API - org.apache.spark.sql.catalyst.optimizer" />
          <meta name="keywords" content="Spark Project Catalyst 3.2.1 API org.apache.spark.sql.catalyst.optimizer" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      
      <link href="../../../../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../../../../lib/jquery.min.js"></script>
      <script type="text/javascript" src="../../../../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../../../../index.js"></script>
      <script type="text/javascript" src="../../../../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../../../../lib/template.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../../../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title">Spark Project Catalyst 3.2.1 API<span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="../../../../../../index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../../../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.org" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="org"></a><a id="org:org"></a>
      <span class="permalink">
      <a href="../../../../../../org/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../../../index.html"><span class="name">org</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="org.apache" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="apache"></a><a id="apache:apache"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../../index.html"><span class="name">apache</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../../index.html" class="extype" name="org">org</a></dd></dl></div>
    </li><li name="org.apache.spark" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="spark"></a><a id="spark:spark"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html"><span class="name">spark</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../index.html" class="extype" name="org.apache">apache</a></dd></dl></div>
    </li><li name="org.apache.spark.sql" visbl="pub" class="indented4 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sql"></a><a id="sql:sql"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">sql</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="org.apache.spark">spark</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst" visbl="pub" class="indented5 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="catalyst"></a><a id="catalyst:catalyst"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Catalyst is a library for manipulating relational query plans." href="../index.html"><span class="name">catalyst</span></a>
      </span>
      
      <p class="shortcomment cmt">Catalyst is a library for manipulating relational query plans.</p><div class="fullcomment"><div class="comment cmt"><p>Catalyst is a library for manipulating relational query plans.  All classes in catalyst are
considered an internal API to Spark SQL and are subject to change between minor releases.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="org.apache.spark.sql">sql</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.analysis" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="analysis"></a><a id="analysis:analysis"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/analysis/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Provides a logical query plan Analyzer and supporting classes for performing analysis." href="../analysis/index.html"><span class="name">analysis</span></a>
      </span>
      
      <p class="shortcomment cmt">Provides a logical query plan <a href="../analysis/Analyzer.html" class="extype" name="org.apache.spark.sql.catalyst.analysis.Analyzer">Analyzer</a> and supporting classes for performing analysis.</p><div class="fullcomment"><div class="comment cmt"><p>Provides a logical query plan <a href="../analysis/Analyzer.html" class="extype" name="org.apache.spark.sql.catalyst.analysis.Analyzer">Analyzer</a> and supporting classes for performing analysis.
Analysis consists of translating <a href="../analysis/UnresolvedAttribute.html" class="extype" name="org.apache.spark.sql.catalyst.analysis.UnresolvedAttribute">UnresolvedAttribute</a>s and <a href="../analysis/UnresolvedRelation.html" class="extype" name="org.apache.spark.sql.catalyst.analysis.UnresolvedRelation">UnresolvedRelation</a>s
into fully typed objects using information in a schema <span class="extype" name="Catalog">Catalog</span>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.catalog" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="catalog"></a><a id="catalog:catalog"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/catalog/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../catalog/index.html"><span class="name">catalog</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.csv" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="csv"></a><a id="csv:csv"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/csv/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../csv/index.html"><span class="name">csv</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.dsl" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dsl"></a><a id="dsl:dsl"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/dsl/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="A collection of implicit conversions that create a DSL for constructing catalyst data structures." href="../dsl/index.html"><span class="name">dsl</span></a>
      </span>
      
      <p class="shortcomment cmt">A collection of implicit conversions that create a DSL for constructing catalyst data structures.</p><div class="fullcomment"><div class="comment cmt"><p>A collection of implicit conversions that create a DSL for constructing catalyst data structures.</p><pre>scala&gt; <span class="kw">import</span> org.apache.spark.sql.catalyst.dsl.expressions._

<span class="cmt">// Standard operators are added to expressions.</span>
scala&gt; <span class="kw">import</span> org.apache.spark.sql.catalyst.expressions.Literal
scala&gt; Literal(<span class="num">1</span>) + Literal(<span class="num">1</span>)
res0: org.apache.spark.sql.catalyst.expressions.Add = (<span class="num">1</span> + <span class="num">1</span>)

<span class="cmt">// There is a conversion from 'symbols to unresolved attributes.</span>
scala&gt; 'a.attr
res1: org.apache.spark.sql.catalyst.analysis.UnresolvedAttribute = 'a

<span class="cmt">// These unresolved attributes can be used to create more complicated expressions.</span>
scala&gt; <span class="lit">'a === '</span>b
res2: org.apache.spark.sql.catalyst.expressions.EqualTo = (<span class="lit">'a = '</span>b)

<span class="cmt">// SQL verbs can be used to construct logical query plans.</span>
scala&gt; <span class="kw">import</span> org.apache.spark.sql.catalyst.plans.logical._
scala&gt; <span class="kw">import</span> org.apache.spark.sql.catalyst.dsl.plans._
scala&gt; LocalRelation('key.int, 'value.string).where('key === <span class="num">1</span>).select('value).analyze
res3: org.apache.spark.sql.catalyst.plans.logical.LogicalPlan =
Project [value#<span class="num">3</span>]
 Filter (key#<span class="num">2</span> = <span class="num">1</span>)
  LocalRelation [key#<span class="num">2</span>,value#<span class="num">3</span>], []</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.encoders" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="encoders"></a><a id="encoders:encoders"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/encoders/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../encoders/index.html"><span class="name">encoders</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.expressions" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="expressions"></a><a id="expressions:expressions"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/expressions/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="A set of classes that can be used to represent trees of relational expressions." href="../expressions/index.html"><span class="name">expressions</span></a>
      </span>
      
      <p class="shortcomment cmt">A set of classes that can be used to represent trees of relational expressions.</p><div class="fullcomment"><div class="comment cmt"><p>A set of classes that can be used to represent trees of relational expressions.  A key goal of
the expression library is to hide the details of naming and scoping from developers who want to
manipulate trees of relational operators. As such, the library defines a special type of
expression, a <a href="../expressions/NamedExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.NamedExpression">NamedExpression</a> in addition to the standard collection of expressions.</p><h4>Standard Expressions</h4><p>A library of standard expressions (e.g., <a href="../expressions/Add.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Add">Add</a>, <a href="../expressions/EqualTo.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.EqualTo">EqualTo</a>), aggregates (e.g., SUM, COUNT),
and other computations (e.g. UDFs). Each expression type is capable of determining its output
schema as a function of its children's output schema.</p><h4>Named Expressions</h4><p>Some expression are named and thus can be referenced by later operators in the dataflow graph.
The two types of named expressions are <a href="../expressions/AttributeReference.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.AttributeReference">AttributeReference</a>s and <a href="../expressions/Alias.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Alias">Alias</a>es.
<a href="../expressions/AttributeReference.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.AttributeReference">AttributeReference</a>s refer to attributes of the input tuple for a given operator and form
the leaves of some expression trees.  Aliases assign a name to intermediate computations.
For example, in the SQL statement <code>SELECT a+b AS c FROM ...</code>, the expressions <code>a</code> and <code>b</code> would
be represented by <code>AttributeReferences</code> and <code>c</code> would be represented by an <code>Alias</code>.</p><p>During <a href="../analysis/index.html" class="extype" name="org.apache.spark.sql.catalyst.analysis">analysis</a>, all named expressions are assigned a globally unique expression id, which
can be used for equality comparisons.  While the original names are kept around for debugging
purposes, they should never be used to check if two attributes refer to the same value, as
plan transformations can result in the introduction of naming ambiguity. For example, consider
a plan that contains subqueries, both of which are reading from the same table.  If an
optimization removes the subqueries, scoping information would be destroyed, eliminating the
ability to reason about which subquery produced a given attribute.</p><h4>Evaluation</h4><p>The result of expressions can be evaluated using the <code>Expression.apply(Row)</code> method.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.json" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="json"></a><a id="json:json"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/json/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../json/index.html"><span class="name">json</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer" visbl="pub" class="indented6 current" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="optimizer"></a><a id="optimizer:optimizer"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">optimizer</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="BooleanSimplification$.html" title="Simplifies boolean expressions: 1."></a>
                        <a href="BooleanSimplification$.html" title="Simplifies boolean expressions: 1.">BooleanSimplification</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="BuildLeft$.html" title=""></a>
                        <a href="BuildLeft$.html" title="">BuildLeft</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="BuildRight$.html" title=""></a>
                        <a href="BuildRight$.html" title="">BuildRight</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="class" href="BuildSide.html" title=""></a>
                        <a href="BuildSide.html" title="">BuildSide</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="CheckCartesianProducts$.html" title="Check if there any cartesian products between joins of any type in the optimized plan tree."></a>
                        <a href="CheckCartesianProducts$.html" title="Check if there any cartesian products between joins of any type in the optimized plan tree.">CheckCartesianProducts</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="CollapseProject$.html" title="Combines two Project operators into one and perform alias substitution, merging the expressions into one single expression for the following cases."></a>
                        <a href="CollapseProject$.html" title="Combines two Project operators into one and perform alias substitution, merging the expressions into one single expression for the following cases.">CollapseProject</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="CollapseRepartition$.html" title="Combines adjacent RepartitionOperation operators"></a>
                        <a href="CollapseRepartition$.html" title="Combines adjacent RepartitionOperation operators">CollapseRepartition</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="CollapseWindow$.html" title="Collapse Adjacent Window Expression."></a>
                        <a href="CollapseWindow$.html" title="Collapse Adjacent Window Expression.">CollapseWindow</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ColumnPruning$.html" title="Attempts to eliminate the reading of unneeded columns from the query plan."></a>
                        <a href="ColumnPruning$.html" title="Attempts to eliminate the reading of unneeded columns from the query plan.">ColumnPruning</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="CombineConcats$.html" title="Combine nested Concat expressions."></a>
                        <a href="CombineConcats$.html" title="Combine nested Concat expressions.">CombineConcats</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="CombineFilters$.html" title="Combines two adjacent Filter operators into one, merging the non-redundant conditions into one conjunctive predicate."></a>
                        <a href="CombineFilters$.html" title="Combines two adjacent Filter operators into one, merging the non-redundant conditions into one conjunctive predicate.">CombineFilters</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="CombineTypedFilters$.html" title="Combines two adjacent TypedFilters, which operate on same type object in condition, into one, merging the filter functions into one conjunctive function."></a>
                        <a href="CombineTypedFilters$.html" title="Combines two adjacent TypedFilters, which operate on same type object in condition, into one, merging the filter functions into one conjunctive function.">CombineTypedFilters</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="CombineUnions$.html" title="Combines all adjacent Union operators into a single Union."></a>
                        <a href="CombineUnions$.html" title="Combines all adjacent Union operators into a single Union.">CombineUnions</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ComputeCurrentTime$.html" title="Computes the current date and time to make sure we return the same result in a single query."></a>
                        <a href="ComputeCurrentTime$.html" title="Computes the current date and time to make sure we return the same result in a single query.">ComputeCurrentTime</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ConstantFolding$.html" title="Replaces Expressions that can be statically evaluated with equivalent Literal values."></a>
                        <a href="ConstantFolding$.html" title="Replaces Expressions that can be statically evaluated with equivalent Literal values.">ConstantFolding</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ConstantPropagation$.html" title="Substitutes Attributes which can be statically evaluated with their corresponding value in conjunctive Expressions e.g."></a>
                        <a href="ConstantPropagation$.html" title="Substitutes Attributes which can be statically evaluated with their corresponding value in conjunctive Expressions e.g.">ConstantPropagation</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ConvertToLocalRelation$.html" title="Converts local operations (i.e."></a>
                        <a href="ConvertToLocalRelation$.html" title="Converts local operations (i.e.">ConvertToLocalRelation</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="class" href="Cost.html" title="This class defines the cost model for a plan."></a>
                        <a href="Cost.html" title="This class defines the cost model for a plan.">Cost</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="CostBasedJoinReorder$.html" title="Cost-based join reorder."></a>
                        <a href="CostBasedJoinReorder$.html" title="Cost-based join reorder.">CostBasedJoinReorder</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="DecimalAggregates$.html" title="Speeds up aggregates on fixed-precision decimals by executing them on unscaled Long values."></a>
                        <a href="DecimalAggregates$.html" title="Speeds up aggregates on fixed-precision decimals by executing them on unscaled Long values.">DecimalAggregates</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="DecorrelateInnerQuery$.html" title="Decorrelate the inner query by eliminating outer references and create domain joins."></a>
                        <a href="DecorrelateInnerQuery$.html" title="Decorrelate the inner query by eliminating outer references and create domain joins.">DecorrelateInnerQuery</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="EliminateAggregateFilter$.html" title="Remove useless FILTER clause for aggregate expressions."></a>
                        <a href="EliminateAggregateFilter$.html" title="Remove useless FILTER clause for aggregate expressions.">EliminateAggregateFilter</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="EliminateDistinct$.html" title="Remove useless DISTINCT for MAX and MIN."></a>
                        <a href="EliminateDistinct$.html" title="Remove useless DISTINCT for MAX and MIN.">EliminateDistinct</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="EliminateLimits$.html" title="This rule optimizes Limit operators by: 1."></a>
                        <a href="EliminateLimits$.html" title="This rule optimizes Limit operators by: 1.">EliminateLimits</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="EliminateMapObjects$.html" title="Removes MapObjects when the following conditions are satisfied"></a>
                        <a href="EliminateMapObjects$.html" title="Removes MapObjects when the following conditions are satisfied">EliminateMapObjects</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="EliminateOuterJoin$.html" title="1."></a>
                        <a href="EliminateOuterJoin$.html" title="1.">EliminateOuterJoin</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="EliminateResolvedHint$.html" title="Replaces ResolvedHint operators from the plan."></a>
                        <a href="EliminateResolvedHint$.html" title="Replaces ResolvedHint operators from the plan.">EliminateResolvedHint</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="EliminateSerialization$.html" title="Removes cases where we are unnecessarily going between the object and serialized (InternalRow) representation of data item."></a>
                        <a href="EliminateSerialization$.html" title="Removes cases where we are unnecessarily going between the object and serialized (InternalRow) representation of data item.">EliminateSerialization</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="EliminateSorts$.html" title="Removes Sort operations if they don't affect the final output ordering."></a>
                        <a href="EliminateSorts$.html" title="Removes Sort operations if they don't affect the final output ordering.">EliminateSorts</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ExtractPythonUDFFromJoinCondition$.html" title="PythonUDF in join condition can't be evaluated if it refers to attributes from both join sides."></a>
                        <a href="ExtractPythonUDFFromJoinCondition$.html" title="PythonUDF in join condition can't be evaluated if it refers to attributes from both join sides.">ExtractPythonUDFFromJoinCondition</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="FoldablePropagation$.html" title="Replace attributes with aliases of the original foldable expressions if possible."></a>
                        <a href="FoldablePropagation$.html" title="Replace attributes with aliases of the original foldable expressions if possible.">FoldablePropagation</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="GeneratorNestedColumnAliasing$.html" title="This prunes unnecessary nested columns from Generate, or Project -&gt; Generate"></a>
                        <a href="GeneratorNestedColumnAliasing$.html" title="This prunes unnecessary nested columns from Generate, or Project -&gt; Generate">GeneratorNestedColumnAliasing</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="InferFiltersFromConstraints$.html" title="Generate a list of additional filters from an operator's existing constraint but remove those that are either already part of the operator's condition or are part of the operator's child constraints."></a>
                        <a href="InferFiltersFromConstraints$.html" title="Generate a list of additional filters from an operator's existing constraint but remove those that are either already part of the operator's condition or are part of the operator's child constraints.">InferFiltersFromConstraints</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="InferFiltersFromGenerate$.html" title="Infers filters from Generate, such that rows that would have been removed by this Generate can be removed earlier - before joins and in data sources."></a>
                        <a href="InferFiltersFromGenerate$.html" title="Infers filters from Generate, such that rows that would have been removed by this Generate can be removed earlier - before joins and in data sources.">InferFiltersFromGenerate</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="InlineCTE$.html" title="Inlines CTE definitions into corresponding references if either of the conditions satisfies: 1."></a>
                        <a href="InlineCTE$.html" title="Inlines CTE definitions into corresponding references if either of the conditions satisfies: 1.">InlineCTE</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="class" href="JoinGraphInfo.html" title="Helper class that keeps information about the join graph as sets of item/plan ids."></a>
                        <a href="JoinGraphInfo.html" title="Helper class that keeps information about the join graph as sets of item/plan ids.">JoinGraphInfo</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="JoinReorderDP$.html" title="Reorder the joins using a dynamic programming algorithm."></a>
                        <a href="JoinReorderDP$.html" title="Reorder the joins using a dynamic programming algorithm.">JoinReorderDP</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="JoinReorderDPFilters$.html" title="Implements optional filters to reduce the search space for join enumeration."></a>
                        <a href="JoinReorderDPFilters$.html" title="Implements optional filters to reduce the search space for join enumeration.">JoinReorderDPFilters</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="trait" href="JoinSelectionHelper.html" title=""></a>
                        <a href="JoinSelectionHelper.html" title="">JoinSelectionHelper</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="LikeSimplification$.html" title="Simplifies LIKE expressions that do not need full regular expressions to evaluate the condition."></a>
                        <a href="LikeSimplification$.html" title="Simplifies LIKE expressions that do not need full regular expressions to evaluate the condition.">LikeSimplification</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="LimitPushDown$.html" title="Pushes down LocalLimit beneath UNION ALL and joins."></a>
                        <a href="LimitPushDown$.html" title="Pushes down LocalLimit beneath UNION ALL and joins.">LimitPushDown</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="LimitPushDownThroughWindow$.html" title="Pushes down LocalLimit beneath WINDOW."></a>
                        <a href="LimitPushDownThroughWindow$.html" title="Pushes down LocalLimit beneath WINDOW.">LimitPushDownThroughWindow</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="NestedColumnAliasing$.html" title="This aims to handle a nested column aliasing pattern inside the ColumnPruning optimizer rule."></a>
                        <a href="NestedColumnAliasing$.html" title="This aims to handle a nested column aliasing pattern inside the ColumnPruning optimizer rule.">NestedColumnAliasing</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="NormalizeFloatingNumbers$.html" title="We need to take care of special floating numbers (NaN and -0.0) in several places:"></a>
                        <a href="NormalizeFloatingNumbers$.html" title="We need to take care of special floating numbers (NaN and -0.0) in several places:">NormalizeFloatingNumbers</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="class" href="NormalizeNaNAndZero.html" title=""></a>
                        <a href="NormalizeNaNAndZero.html" title="">NormalizeNaNAndZero</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="NullPropagation$.html" title="Replaces Expressions that can be statically evaluated with equivalent Literal values."></a>
                        <a href="NullPropagation$.html" title="Replaces Expressions that can be statically evaluated with equivalent Literal values.">NullPropagation</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ObjectSerializerPruning$.html" title="Prunes unnecessary object serializers from query plan."></a>
                        <a href="ObjectSerializerPruning$.html" title="Prunes unnecessary object serializers from query plan.">ObjectSerializerPruning</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="OptimizeCsvJsonExprs$.html" title="Simplify redundant csv/json related expressions."></a>
                        <a href="OptimizeCsvJsonExprs$.html" title="Simplify redundant csv/json related expressions.">OptimizeCsvJsonExprs</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="OptimizeIn$.html" title="Optimize IN predicates: 1."></a>
                        <a href="OptimizeIn$.html" title="Optimize IN predicates: 1.">OptimizeIn</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="OptimizeLimitZero$.html" title="Replaces GlobalLimit 0 and LocalLimit 0 nodes (subtree) with empty Local Relation, as they don't return any rows."></a>
                        <a href="OptimizeLimitZero$.html" title="Replaces GlobalLimit 0 and LocalLimit 0 nodes (subtree) with empty Local Relation, as they don't return any rows.">OptimizeLimitZero</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="OptimizeOneRowRelationSubquery$.html" title="This rule optimizes subqueries with OneRowRelation as leaf nodes."></a>
                        <a href="OptimizeOneRowRelationSubquery$.html" title="This rule optimizes subqueries with OneRowRelation as leaf nodes.">OptimizeOneRowRelationSubquery</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="OptimizeRepartition$.html" title="Replace RepartitionByExpression numPartitions to 1 if all partition expressions are foldable and user not specify."></a>
                        <a href="OptimizeRepartition$.html" title="Replace RepartitionByExpression numPartitions to 1 if all partition expressions are foldable and user not specify.">OptimizeRepartition</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="OptimizeUpdateFields$.html" title="Optimizes UpdateFields expression chains."></a>
                        <a href="OptimizeUpdateFields$.html" title="Optimizes UpdateFields expression chains.">OptimizeUpdateFields</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="OptimizeWindowFunctions$.html" title="Replaces first(col) to nth_value(col, 1) for better performance."></a>
                        <a href="OptimizeWindowFunctions$.html" title="Replaces first(col) to nth_value(col, 1) for better performance.">OptimizeWindowFunctions</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="class" href="Optimizer.html" title="Abstract class all optimizers should inherit of, contains the standard batches (extending Optimizers can override this."></a>
                        <a href="Optimizer.html" title="Abstract class all optimizers should inherit of, contains the standard batches (extending Optimizers can override this.">Optimizer</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="class" href="OrderedJoin.html" title="This is a mimic class for a join node that has been ordered."></a>
                        <a href="OrderedJoin.html" title="This is a mimic class for a join node that has been ordered.">OrderedJoin</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="PropagateEmptyRelation$.html" title="This rule runs in the normal optimizer and optimizes more cases compared to PropagateEmptyRelationBase: 1."></a>
                        <a href="PropagateEmptyRelation$.html" title="This rule runs in the normal optimizer and optimizes more cases compared to PropagateEmptyRelationBase: 1.">PropagateEmptyRelation</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="class" href="PropagateEmptyRelationBase.html" title="The base class of two rules in the normal and AQE Optimizer."></a>
                        <a href="PropagateEmptyRelationBase.html" title="The base class of two rules in the normal and AQE Optimizer.">PropagateEmptyRelationBase</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="PruneFilters$.html" title="Removes filters that can be evaluated trivially."></a>
                        <a href="PruneFilters$.html" title="Removes filters that can be evaluated trivially.">PruneFilters</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="PullOutGroupingExpressions$.html" title="This rule ensures that Aggregate nodes doesn't contain complex grouping expressions in the optimization phase."></a>
                        <a href="PullOutGroupingExpressions$.html" title="This rule ensures that Aggregate nodes doesn't contain complex grouping expressions in the optimization phase.">PullOutGroupingExpressions</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="PullupCorrelatedPredicates$.html" title="Pull out all (outer) correlated predicates from a given subquery."></a>
                        <a href="PullupCorrelatedPredicates$.html" title="Pull out all (outer) correlated predicates from a given subquery.">PullupCorrelatedPredicates</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="PushDownLeftSemiAntiJoin$.html" title="This rule is a variant of PushPredicateThroughNonJoin which can handle pushing down Left semi and Left Anti joins below the following operators."></a>
                        <a href="PushDownLeftSemiAntiJoin$.html" title="This rule is a variant of PushPredicateThroughNonJoin which can handle pushing down Left semi and Left Anti joins below the following operators.">PushDownLeftSemiAntiJoin</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="PushDownPredicates$.html" title="The unified version for predicate pushdown of normal operators and joins."></a>
                        <a href="PushDownPredicates$.html" title="The unified version for predicate pushdown of normal operators and joins.">PushDownPredicates</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="PushExtraPredicateThroughJoin$.html" title="Try pushing down disjunctive join condition into left and right child."></a>
                        <a href="PushExtraPredicateThroughJoin$.html" title="Try pushing down disjunctive join condition into left and right child.">PushExtraPredicateThroughJoin</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="PushFoldableIntoBranches$.html" title="Push the foldable expression into (if / case) branches."></a>
                        <a href="PushFoldableIntoBranches$.html" title="Push the foldable expression into (if / case) branches.">PushFoldableIntoBranches</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="PushLeftSemiLeftAntiThroughJoin$.html" title="This rule is a variant of PushPredicateThroughJoin which can handle pushing down Left semi and Left Anti joins below a join operator."></a>
                        <a href="PushLeftSemiLeftAntiThroughJoin$.html" title="This rule is a variant of PushPredicateThroughJoin which can handle pushing down Left semi and Left Anti joins below a join operator.">PushLeftSemiLeftAntiThroughJoin</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="PushPredicateThroughJoin$.html" title="Pushes down Filter operators where the condition can be evaluated using only the attributes of the left or right side of a join."></a>
                        <a href="PushPredicateThroughJoin$.html" title="Pushes down Filter operators where the condition can be evaluated using only the attributes of the left or right side of a join.">PushPredicateThroughJoin</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="PushPredicateThroughNonJoin$.html" title="Pushes Filter operators through many operators iff: 1) the operator is deterministic 2) the predicate is deterministic and the operator will not change any of rows."></a>
                        <a href="PushPredicateThroughNonJoin$.html" title="Pushes Filter operators through many operators iff: 1) the operator is deterministic 2) the predicate is deterministic and the operator will not change any of rows.">PushPredicateThroughNonJoin</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="PushProjectionThroughUnion$.html" title="Pushes Project operator to both sides of a Union operator."></a>
                        <a href="PushProjectionThroughUnion$.html" title="Pushes Project operator to both sides of a Union operator.">PushProjectionThroughUnion</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ReassignLambdaVariableID$.html" title="Reassigns per-query unique IDs to LambdaVariables, whose original IDs are globally unique."></a>
                        <a href="ReassignLambdaVariableID$.html" title="Reassigns per-query unique IDs to LambdaVariables, whose original IDs are globally unique.">ReassignLambdaVariableID</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RemoveDispensableExpressions$.html" title="Removes nodes that are not necessary."></a>
                        <a href="RemoveDispensableExpressions$.html" title="Removes nodes that are not necessary.">RemoveDispensableExpressions</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RemoveLiteralFromGroupExpressions$.html" title="Removes literals from group expressions in Aggregate, as they have no effect to the result but only makes the grouping key bigger."></a>
                        <a href="RemoveLiteralFromGroupExpressions$.html" title="Removes literals from group expressions in Aggregate, as they have no effect to the result but only makes the grouping key bigger.">RemoveLiteralFromGroupExpressions</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RemoveNoopOperators$.html" title="Remove no-op operators from the query plan that do not make any modifications."></a>
                        <a href="RemoveNoopOperators$.html" title="Remove no-op operators from the query plan that do not make any modifications.">RemoveNoopOperators</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RemoveNoopUnion$.html" title="Smplify the children of Union or remove no-op Union from the query plan that do not make any modifications to the query."></a>
                        <a href="RemoveNoopUnion$.html" title="Smplify the children of Union or remove no-op Union from the query plan that do not make any modifications to the query.">RemoveNoopUnion</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RemoveRedundantAggregates$.html" title="Remove redundant aggregates from a query plan."></a>
                        <a href="RemoveRedundantAggregates$.html" title="Remove redundant aggregates from a query plan.">RemoveRedundantAggregates</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RemoveRedundantAliases$.html" title="Remove redundant aliases from a query plan."></a>
                        <a href="RemoveRedundantAliases$.html" title="Remove redundant aliases from a query plan.">RemoveRedundantAliases</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RemoveRepetitionFromGroupExpressions$.html" title="Removes repetition from group expressions in Aggregate, as they have no effect to the result but only makes the grouping key bigger."></a>
                        <a href="RemoveRepetitionFromGroupExpressions$.html" title="Removes repetition from group expressions in Aggregate, as they have no effect to the result but only makes the grouping key bigger.">RemoveRepetitionFromGroupExpressions</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ReorderAssociativeOperator$.html" title="Reorder associative integral-type operators and fold all constants into one."></a>
                        <a href="ReorderAssociativeOperator$.html" title="Reorder associative integral-type operators and fold all constants into one.">ReorderAssociativeOperator</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ReorderJoin$.html" title="Reorder the joins and push all the conditions into join, so that the bottom ones have at least one condition."></a>
                        <a href="ReorderJoin$.html" title="Reorder the joins and push all the conditions into join, so that the bottom ones have at least one condition.">ReorderJoin</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="class" href="ReplaceCurrentLike.html" title="Replaces the expression of CurrentDatabase with the current database name."></a>
                        <a href="ReplaceCurrentLike.html" title="Replaces the expression of CurrentDatabase with the current database name.">ReplaceCurrentLike</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ReplaceDeduplicateWithAggregate$.html" title="Replaces logical Deduplicate operator with an Aggregate operator."></a>
                        <a href="ReplaceDeduplicateWithAggregate$.html" title="Replaces logical Deduplicate operator with an Aggregate operator.">ReplaceDeduplicateWithAggregate</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ReplaceDistinctWithAggregate$.html" title="Replaces logical Distinct operator with an Aggregate operator."></a>
                        <a href="ReplaceDistinctWithAggregate$.html" title="Replaces logical Distinct operator with an Aggregate operator.">ReplaceDistinctWithAggregate</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ReplaceExceptWithAntiJoin$.html" title="Replaces logical Except operator with a left-anti Join operator."></a>
                        <a href="ReplaceExceptWithAntiJoin$.html" title="Replaces logical Except operator with a left-anti Join operator.">ReplaceExceptWithAntiJoin</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ReplaceExceptWithFilter$.html" title="If one or both of the datasets in the logical Except operator are purely transformed using Filter, this rule will replace logical Except operator with a Filter operator by flipping the filter condition of the right child."></a>
                        <a href="ReplaceExceptWithFilter$.html" title="If one or both of the datasets in the logical Except operator are purely transformed using Filter, this rule will replace logical Except operator with a Filter operator by flipping the filter condition of the right child.">ReplaceExceptWithFilter</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ReplaceExpressions$.html" title="Finds all the expressions that are unevaluable and replace/rewrite them with semantically equivalent expressions that can be evaluated."></a>
                        <a href="ReplaceExpressions$.html" title="Finds all the expressions that are unevaluable and replace/rewrite them with semantically equivalent expressions that can be evaluated.">ReplaceExpressions</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ReplaceIntersectWithSemiJoin$.html" title="Replaces logical Intersect operator with a left-semi Join operator."></a>
                        <a href="ReplaceIntersectWithSemiJoin$.html" title="Replaces logical Intersect operator with a left-semi Join operator.">ReplaceIntersectWithSemiJoin</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ReplaceNullWithFalseInPredicate$.html" title="A rule that replaces Literal(null, BooleanType) with FalseLiteral, if possible, in the search condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator &quot;(search condition) = TRUE&quot;."></a>
                        <a href="ReplaceNullWithFalseInPredicate$.html" title="A rule that replaces Literal(null, BooleanType) with FalseLiteral, if possible, in the search condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator &quot;(search condition) = TRUE&quot;.">ReplaceNullWithFalseInPredicate</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="ReplaceUpdateFieldsExpression$.html" title="Replaces UpdateFields expression with an evaluable expression."></a>
                        <a href="ReplaceUpdateFieldsExpression$.html" title="Replaces UpdateFields expression with an evaluable expression.">ReplaceUpdateFieldsExpression</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RewriteCorrelatedScalarSubquery$.html" title="This rule rewrites correlated ScalarSubquery expressions into LEFT OUTER joins."></a>
                        <a href="RewriteCorrelatedScalarSubquery$.html" title="This rule rewrites correlated ScalarSubquery expressions into LEFT OUTER joins.">RewriteCorrelatedScalarSubquery</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RewriteDistinctAggregates$.html" title="This rule rewrites an aggregate query with distinct aggregations into an expanded double aggregation in which the regular aggregation expressions and every distinct clause is aggregated in a separate group."></a>
                        <a href="RewriteDistinctAggregates$.html" title="This rule rewrites an aggregate query with distinct aggregations into an expanded double aggregation in which the regular aggregation expressions and every distinct clause is aggregated in a separate group.">RewriteDistinctAggregates</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RewriteExceptAll$.html" title="Replaces logical Except operator using a combination of Union, Aggregate and Generate operator."></a>
                        <a href="RewriteExceptAll$.html" title="Replaces logical Except operator using a combination of Union, Aggregate and Generate operator.">RewriteExceptAll</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RewriteIntersectAll$.html" title="Replaces logical Intersect operator using a combination of Union, Aggregate and Generate operator."></a>
                        <a href="RewriteIntersectAll$.html" title="Replaces logical Intersect operator using a combination of Union, Aggregate and Generate operator.">RewriteIntersectAll</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RewriteLateralSubquery$.html" title="This rule rewrites LateralSubquery expressions into joins."></a>
                        <a href="RewriteLateralSubquery$.html" title="This rule rewrites LateralSubquery expressions into joins.">RewriteLateralSubquery</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RewriteNonCorrelatedExists$.html" title="Rewrite non correlated exists subquery to use ScalarSubquery WHERE EXISTS (SELECT A FROM TABLE B WHERE COL1 &gt; 10) will be rewritten to WHERE (SELECT 1 FROM (SELECT A FROM TABLE B WHERE COL1 &gt; 10) LIMIT 1) IS NOT NULL"></a>
                        <a href="RewriteNonCorrelatedExists$.html" title="Rewrite non correlated exists subquery to use ScalarSubquery WHERE EXISTS (SELECT A FROM TABLE B WHERE COL1 &gt; 10) will be rewritten to WHERE (SELECT 1 FROM (SELECT A FROM TABLE B WHERE COL1 &gt; 10) LIMIT 1) IS NOT NULL">RewriteNonCorrelatedExists</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="RewritePredicateSubquery$.html" title="This rule rewrites predicate sub-queries into left semi/anti joins."></a>
                        <a href="RewritePredicateSubquery$.html" title="This rule rewrites predicate sub-queries into left semi/anti joins.">RewritePredicateSubquery</a>
                      </li><li class="current-entities indented6">
                        <a class="object" href="SimpleTestOptimizer$.html" title="An optimizer used in test code."></a>
                        <a class="class" href="SimpleTestOptimizer.html" title=""></a>
                        <a href="SimpleTestOptimizer.html" title="">SimpleTestOptimizer</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="SimplifyBinaryComparison$.html" title="Simplifies binary comparisons with semantically-equal expressions: 1) Replace '&lt;=&gt;' with 'true' literal."></a>
                        <a href="SimplifyBinaryComparison$.html" title="Simplifies binary comparisons with semantically-equal expressions: 1) Replace '&lt;=&gt;' with 'true' literal.">SimplifyBinaryComparison</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="SimplifyCaseConversionExpressions$.html" title="Removes the inner case conversion expressions that are unnecessary because the inner conversion is overwritten by the outer one."></a>
                        <a href="SimplifyCaseConversionExpressions$.html" title="Removes the inner case conversion expressions that are unnecessary because the inner conversion is overwritten by the outer one.">SimplifyCaseConversionExpressions</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="SimplifyCasts$.html" title="Removes Casts that are unnecessary because the input is already the correct type."></a>
                        <a href="SimplifyCasts$.html" title="Removes Casts that are unnecessary because the input is already the correct type.">SimplifyCasts</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="SimplifyConditionals$.html" title="Simplifies conditional expressions (if / case)."></a>
                        <a href="SimplifyConditionals$.html" title="Simplifies conditional expressions (if / case).">SimplifyConditionals</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="SimplifyConditionalsInPredicate$.html" title="A rule that converts conditional expressions to predicate expressions, if possible, in the search condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator &quot;(search condition) = TRUE&quot;."></a>
                        <a href="SimplifyConditionalsInPredicate$.html" title="A rule that converts conditional expressions to predicate expressions, if possible, in the search condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator &quot;(search condition) = TRUE&quot;.">SimplifyConditionalsInPredicate</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="SimplifyExtractValueOps$.html" title="Simplify redundant CreateNamedStruct, CreateArray and CreateMap expressions."></a>
                        <a href="SimplifyExtractValueOps$.html" title="Simplify redundant CreateNamedStruct, CreateArray and CreateMap expressions.">SimplifyExtractValueOps</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="SpecialDatetimeValues$.html" title="Replaces casts of special datetime strings by its date/timestamp values if the input strings are foldable."></a>
                        <a href="SpecialDatetimeValues$.html" title="Replaces casts of special datetime strings by its date/timestamp values if the input strings are foldable.">SpecialDatetimeValues</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="StarSchemaDetection$.html" title="Encapsulates star-schema detection logic."></a>
                        <a href="StarSchemaDetection$.html" title="Encapsulates star-schema detection logic.">StarSchemaDetection</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="TransposeWindow$.html" title="Transpose Adjacent Window Expressions."></a>
                        <a href="TransposeWindow$.html" title="Transpose Adjacent Window Expressions.">TransposeWindow</a>
                      </li><li class="current-entities indented6">
                        <span class="separator"></span>
                        <a class="object" href="UnwrapCastInBinaryComparison$.html" title="Unwrap casts in binary comparison or In/InSet operations with patterns like following:"></a>
                        <a href="UnwrapCastInBinaryComparison$.html" title="Unwrap casts in binary comparison or In/InSet operations with patterns like following:">UnwrapCastInBinaryComparison</a>
                      </li><li name="org.apache.spark.sql.catalyst.parser" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parser"></a><a id="parser:parser"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/parser/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../parser/index.html"><span class="name">parser</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.planning" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="planning"></a><a id="planning:planning"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/planning/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="Contains classes for enumerating possible physical plans for a given logical query plan." href="../planning/index.html"><span class="name">planning</span></a>
      </span>
      
      <p class="shortcomment cmt">Contains classes for enumerating possible physical plans for a given logical query plan.</p><div class="fullcomment"><div class="comment cmt"><p>Contains classes for enumerating possible physical plans for a given logical query plan.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.plans" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="plans"></a><a id="plans:plans"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/plans/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="A collection of common abstractions for query plans as well as a base logical plan representation." href="../plans/index.html"><span class="name">plans</span></a>
      </span>
      
      <p class="shortcomment cmt">A collection of common abstractions for query plans as well as
a base logical plan representation.</p><div class="fullcomment"><div class="comment cmt"><p>A collection of common abstractions for query plans as well as
a base logical plan representation.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.rules" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rules"></a><a id="rules:rules"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/rules/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="A framework for applying batches rewrite rules to trees, possibly to fixed point." href="../rules/index.html"><span class="name">rules</span></a>
      </span>
      
      <p class="shortcomment cmt">A framework for applying batches rewrite rules to trees, possibly to fixed point.</p><div class="fullcomment"><div class="comment cmt"><p>A framework for applying batches rewrite rules to trees, possibly to fixed point.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.streaming" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="streaming"></a><a id="streaming:streaming"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/streaming/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../streaming/index.html"><span class="name">streaming</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.trees" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="trees"></a><a id="trees:trees"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/trees/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="A library for easily manipulating trees of operators." href="../trees/index.html"><span class="name">trees</span></a>
      </span>
      
      <p class="shortcomment cmt">A library for easily manipulating trees of operators.</p><div class="fullcomment"><div class="comment cmt"><p>A library for easily manipulating trees of operators.  Operators that extend TreeNode are
granted the following interface:</p><ul><li>Scala collection like methods (foreach, map, flatMap, collect, etc)</li></ul><p> -
    transform - accepts a partial function that is used to generate a new tree.  When the
    partial function can be applied to a given tree segment, that segment is replaced with the
    result.  After attempting to apply the partial function to a given node, the transform
    function recursively attempts to apply the function to that node's children.</p><ul><li>debugging support - pretty printing, easy splicing of trees, etc.</li></ul></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.util" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="util"></a><a id="util:util"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/util/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../util/index.html"><span class="name">util</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></dd></dl></div>
    </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="package value">
      <div id="definition">
        <div class="big-circle package">p</div>
        <p id="owner"><a href="../../../../../index.html" class="extype" name="org">org</a>.<a href="../../../../index.html" class="extype" name="org.apache">apache</a>.<a href="../../../index.html" class="extype" name="org.apache.spark">spark</a>.<a href="../../index.html" class="extype" name="org.apache.spark.sql">sql</a>.<a href="../index.html" class="extype" name="org.apache.spark.sql.catalyst">catalyst</a></p>
        <h1>optimizer<span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">optimizer</span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              
            </ol>
          </div>
          
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="org.apache.spark.sql.catalyst.optimizer.BuildSide" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="BuildSideextendsAnyRef"></a><a id="BuildSide:BuildSide"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/BuildSide.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">sealed abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="" href="BuildSide.html"><span class="name">BuildSide</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      
    </li><li name="org.apache.spark.sql.catalyst.optimizer.Cost" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="CostextendsProductwithSerializable"></a><a id="Cost:Cost"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/Cost.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="This class defines the cost model for a plan." href="Cost.html"><span class="name">Cost</span></a><span class="params">(<span name="card">card: <span class="extype" name="scala.BigInt">BigInt</span></span>, <span name="size">size: <span class="extype" name="scala.BigInt">BigInt</span></span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">This class defines the cost model for a plan.</p><div class="fullcomment"><div class="comment cmt"><p>This class defines the cost model for a plan.</p></div><dl class="paramcmts block"><dt class="param">card</dt><dd class="cmt"><p>Cardinality (number of rows).</p></dd><dt class="param">size</dt><dd class="cmt"><p>Size in bytes.</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.JoinGraphInfo" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="JoinGraphInfoextendsProductwithSerializable"></a><a id="JoinGraphInfo:JoinGraphInfo"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/JoinGraphInfo.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="Helper class that keeps information about the join graph as sets of item/plan ids." href="JoinGraphInfo.html"><span class="name">JoinGraphInfo</span></a><span class="params">(<span name="starJoins">starJoins: <span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scala.Int">Int</span>]</span>, <span name="nonStarJoins">nonStarJoins: <span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scala.Int">Int</span>]</span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Helper class that keeps information about the join graph as sets of item/plan ids.</p><div class="fullcomment"><div class="comment cmt"><p>Helper class that keeps information about the join graph as sets of item/plan ids.
It currently stores the star/non-star plans. It can be
extended with the set of connected/unconnected plans.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.JoinSelectionHelper" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="JoinSelectionHelperextendsAnyRef"></a><a id="JoinSelectionHelper:JoinSelectionHelper"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/JoinSelectionHelper.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="" href="JoinSelectionHelper.html"><span class="name">JoinSelectionHelper</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      
    </li><li name="org.apache.spark.sql.catalyst.optimizer.NormalizeNaNAndZero" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="NormalizeNaNAndZeroextendsUnaryExpressionwithExpectsInputTypeswithProductwithSerializable"></a><a id="NormalizeNaNAndZero:NormalizeNaNAndZero"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/NormalizeNaNAndZero.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="" href="NormalizeNaNAndZero.html"><span class="name">NormalizeNaNAndZero</span></a><span class="params">(<span name="child">child: <a href="../expressions/Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a></span>)</span><span class="result"> extends <a href="../expressions/UnaryExpression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.UnaryExpression">UnaryExpression</a> with <a href="../expressions/ExpectsInputTypes.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.ExpectsInputTypes">ExpectsInputTypes</a> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      
    </li><li name="org.apache.spark.sql.catalyst.optimizer.Optimizer" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="OptimizerextendsRuleExecutor[org.apache.spark.sql.catalyst.plans.logical.LogicalPlan]"></a><a id="Optimizer:Optimizer"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/Optimizer.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Abstract class all optimizers should inherit of, contains the standard batches (extending Optimizers can override this." href="Optimizer.html"><span class="name">Optimizer</span></a><span class="result"> extends <a href="../rules/RuleExecutor.html" class="extype" name="org.apache.spark.sql.catalyst.rules.RuleExecutor">RuleExecutor</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Abstract class all optimizers should inherit of, contains the standard batches (extending
Optimizers can override this.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.OrderedJoin" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="OrderedJoinextendsLogicalPlanwithBinaryNodewithProductwithSerializable"></a><a id="OrderedJoin:OrderedJoin"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/OrderedJoin.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="This is a mimic class for a join node that has been ordered." href="OrderedJoin.html"><span class="name">OrderedJoin</span></a><span class="params">(<span name="left">left: <a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a></span>, <span name="right">right: <a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a></span>, <span name="joinType">joinType: <a href="../plans/JoinType.html" class="extype" name="org.apache.spark.sql.catalyst.plans.JoinType">JoinType</a></span>, <span name="condition">condition: <span class="extype" name="scala.Option">Option</span>[<a href="../expressions/Expression.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.Expression">Expression</a>]</span>)</span><span class="result"> extends <a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a> with <a href="../plans/logical/BinaryNode.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.BinaryNode">BinaryNode</a> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">This is a mimic class for a join node that has been ordered.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.PropagateEmptyRelationBase" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="PropagateEmptyRelationBaseextendsRule[org.apache.spark.sql.catalyst.plans.logical.LogicalPlan]withCastSupport"></a><a id="PropagateEmptyRelationBase:PropagateEmptyRelationBase"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/PropagateEmptyRelationBase.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="The base class of two rules in the normal and AQE Optimizer." href="PropagateEmptyRelationBase.html"><span class="name">PropagateEmptyRelationBase</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../analysis/CastSupport.html" class="extype" name="org.apache.spark.sql.catalyst.analysis.CastSupport">CastSupport</a></span>
      </span>
      
      <p class="shortcomment cmt">The base class of two rules in the normal and AQE Optimizer.</p><div class="fullcomment"><div class="comment cmt"><p>The base class of two rules in the normal and AQE Optimizer. It simplifies query plans with
empty or non-empty relations:</p><ol class="decimal"><li>Binary-node Logical Plans<ul><li>Join with one or two empty children (including Intersect/Except).</li><li>Left semi Join
      Right side is non-empty and condition is empty. Eliminate join to its left side.</li><li>Left anti join
      Right side is non-empty and condition is empty. Eliminate join to an empty
      <span class="extype" name="LocalRelation">LocalRelation</span>.
 2. Unary-node Logical Plans</li><li>Limit/Repartition with all empty children.</li><li>Aggregate with all empty children and at least one grouping expression.</li><li>Generate(Explode) with all empty children. Others like Hive UDTF may return results.
</li></ul></li></ol></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ReplaceCurrentLike" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ReplaceCurrentLikeextendsRule[org.apache.spark.sql.catalyst.plans.logical.LogicalPlan]withProductwithSerializable"></a><a id="ReplaceCurrentLike:ReplaceCurrentLike"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ReplaceCurrentLike.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="Replaces the expression of CurrentDatabase with the current database name." href="ReplaceCurrentLike.html"><span class="name">ReplaceCurrentLike</span></a><span class="params">(<span name="catalogManager">catalogManager: <span class="extype" name="org.apache.spark.sql.connector.catalog.CatalogManager">CatalogManager</span></span>)</span><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">Replaces the expression of CurrentDatabase with the current database name.</p><div class="fullcomment"><div class="comment cmt"><p>Replaces the expression of CurrentDatabase with the current database name.
Replaces the expression of CurrentCatalog with the current catalog name.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.SimpleTestOptimizer" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SimpleTestOptimizerextendsOptimizer"></a><a id="SimpleTestOptimizer:SimpleTestOptimizer"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/SimpleTestOptimizer.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="" href="SimpleTestOptimizer.html"><span class="name">SimpleTestOptimizer</span></a><span class="result"> extends <a href="Optimizer.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.Optimizer">Optimizer</a></span>
      </span>
      
      
    </li></ol>
            </div>

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="org.apache.spark.sql.catalyst.optimizer.BooleanSimplification" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="BooleanSimplification"></a><a id="BooleanSimplification:BooleanSimplification"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/BooleanSimplification$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Simplifies boolean expressions: 1." href="BooleanSimplification$.html"><span class="name">BooleanSimplification</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Simplifies boolean expressions:
1.</p><div class="fullcomment"><div class="comment cmt"><p>Simplifies boolean expressions:
1. Simplifies expressions whose answer can be determined without evaluating both sides.
2. Eliminates / extracts common factors.
3. Merge same expressions
4. Removes <code>Not</code> operator.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.BuildLeft" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="BuildLeft"></a><a id="BuildLeft:BuildLeft"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/BuildLeft$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="BuildLeft$.html"><span class="name">BuildLeft</span></a><span class="result"> extends <a href="BuildSide.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.BuildSide">BuildSide</a> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      
    </li><li name="org.apache.spark.sql.catalyst.optimizer.BuildRight" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="BuildRight"></a><a id="BuildRight:BuildRight"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/BuildRight$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="BuildRight$.html"><span class="name">BuildRight</span></a><span class="result"> extends <a href="BuildSide.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.BuildSide">BuildSide</a> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      
    </li><li name="org.apache.spark.sql.catalyst.optimizer.CheckCartesianProducts" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="CheckCartesianProducts"></a><a id="CheckCartesianProducts:CheckCartesianProducts"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/CheckCartesianProducts$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Check if there any cartesian products between joins of any type in the optimized plan tree." href="CheckCartesianProducts$.html"><span class="name">CheckCartesianProducts</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Check if there any cartesian products between joins of any type in the optimized plan tree.</p><div class="fullcomment"><div class="comment cmt"><p>Check if there any cartesian products between joins of any type in the optimized plan tree.
Throw an error if a cartesian product is found without an explicit cross join specified.
This rule is effectively disabled if the CROSS_JOINS_ENABLED flag is true.</p><p>This rule must be run AFTER the ReorderJoin rule since the join conditions for each join must be
collected before checking if it is a cartesian product. If you have
SELECT * from R, S where R.r = S.s,
the join between R and S is not a cartesian product and therefore should be allowed.
The predicate R.r = S.s is not recognized as a join condition until the ReorderJoin rule.</p><p>This rule must be run AFTER the batch &quot;LocalRelation&quot;, since a join with empty relation should
not be a cartesian product.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.CollapseProject" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="CollapseProject"></a><a id="CollapseProject:CollapseProject"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/CollapseProject$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Combines two Project operators into one and perform alias substitution, merging the expressions into one single expression for the following cases." href="CollapseProject$.html"><span class="name">CollapseProject</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/AliasHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.AliasHelper">AliasHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Combines two <span class="extype" name="Project">Project</span> operators into one and perform alias substitution,
merging the expressions into one single expression for the following cases.</p><div class="fullcomment"><div class="comment cmt"><p>Combines two <span class="extype" name="Project">Project</span> operators into one and perform alias substitution,
merging the expressions into one single expression for the following cases.
1. When two <span class="extype" name="Project">Project</span> operators are adjacent.
2. When two <span class="extype" name="Project">Project</span> operators have LocalLimit/Sample/Repartition operator between them
   and the upper project consists of the same number of columns which is equal or aliasing.
   <code>GlobalLimit(LocalLimit)</code> pattern is also considered.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.CollapseRepartition" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="CollapseRepartition"></a><a id="CollapseRepartition:CollapseRepartition"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/CollapseRepartition$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Combines adjacent RepartitionOperation operators" href="CollapseRepartition$.html"><span class="name">CollapseRepartition</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Combines adjacent <span class="extype" name="RepartitionOperation">RepartitionOperation</span> operators
</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.CollapseWindow" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="CollapseWindow"></a><a id="CollapseWindow:CollapseWindow"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/CollapseWindow$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Collapse Adjacent Window Expression." href="CollapseWindow$.html"><span class="name">CollapseWindow</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Collapse Adjacent Window Expression.</p><div class="fullcomment"><div class="comment cmt"><p>Collapse Adjacent Window Expression.
- If the partition specs and order specs are the same and the window expression are
  independent and are of the same window function type, collapse into the parent.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ColumnPruning" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ColumnPruning"></a><a id="ColumnPruning:ColumnPruning"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ColumnPruning$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Attempts to eliminate the reading of unneeded columns from the query plan." href="ColumnPruning$.html"><span class="name">ColumnPruning</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to eliminate the reading of unneeded columns from the query plan.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to eliminate the reading of unneeded columns from the query plan.</p><p>Since adding Project before Filter conflicts with PushPredicatesThroughProject, this rule will
remove the Project p2 in the following pattern:</p><p>  p1 @ Project(_, Filter(_, p2 @ Project(_, child))) if p2.outputSet.subsetOf(p2.inputSet)</p><p>p2 is usually inserted by this rule and useless, p1 could prune the columns anyway.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.CombineConcats" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="CombineConcats"></a><a id="CombineConcats:CombineConcats"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/CombineConcats$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Combine nested Concat expressions." href="CombineConcats$.html"><span class="name">CombineConcats</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Combine nested <span class="extype" name="Concat">Concat</span> expressions.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.CombineFilters" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="CombineFilters"></a><a id="CombineFilters:CombineFilters"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/CombineFilters$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Combines two adjacent Filter operators into one, merging the non-redundant conditions into one conjunctive predicate." href="CombineFilters$.html"><span class="name">CombineFilters</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Combines two adjacent <span class="extype" name="Filter">Filter</span> operators into one, merging the non-redundant conditions into
one conjunctive predicate.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.CombineTypedFilters" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="CombineTypedFilters"></a><a id="CombineTypedFilters:CombineTypedFilters"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/CombineTypedFilters$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Combines two adjacent TypedFilters, which operate on same type object in condition, into one, merging the filter functions into one conjunctive function." href="CombineTypedFilters$.html"><span class="name">CombineTypedFilters</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Combines two adjacent <span class="extype" name="TypedFilter">TypedFilter</span>s, which operate on same type object in condition, into one,
merging the filter functions into one conjunctive function.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.CombineUnions" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="CombineUnions"></a><a id="CombineUnions:CombineUnions"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/CombineUnions$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Combines all adjacent Union operators into a single Union." href="CombineUnions$.html"><span class="name">CombineUnions</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Combines all adjacent <span class="extype" name="Union">Union</span> operators into a single <span class="extype" name="Union">Union</span>.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ComputeCurrentTime" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ComputeCurrentTime"></a><a id="ComputeCurrentTime:ComputeCurrentTime"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ComputeCurrentTime$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Computes the current date and time to make sure we return the same result in a single query." href="ComputeCurrentTime$.html"><span class="name">ComputeCurrentTime</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Computes the current date and time to make sure we return the same result in a single query.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ConstantFolding" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ConstantFolding"></a><a id="ConstantFolding:ConstantFolding"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ConstantFolding$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replaces Expressions that can be statically evaluated with equivalent Literal values." href="ConstantFolding$.html"><span class="name">ConstantFolding</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replaces <span class="extype" name="Expression">Expressions</span> that can be statically evaluated with
equivalent <span class="extype" name="Literal">Literal</span> values.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ConstantPropagation" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ConstantPropagation"></a><a id="ConstantPropagation:ConstantPropagation"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ConstantPropagation$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Substitutes Attributes which can be statically evaluated with their corresponding value in conjunctive Expressions e.g." href="ConstantPropagation$.html"><span class="name">ConstantPropagation</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Substitutes <span class="extype" name="Attribute">Attributes</span> which can be statically evaluated with their corresponding
value in conjunctive <span class="extype" name="Expression">Expressions</span>
e.g.</p><div class="fullcomment"><div class="comment cmt"><p>Substitutes <span class="extype" name="Attribute">Attributes</span> which can be statically evaluated with their corresponding
value in conjunctive <span class="extype" name="Expression">Expressions</span>
e.g.</p><pre>SELECT * FROM table WHERE i = <span class="num">5</span> AND j = i + <span class="num">3</span>
=<span class="kw">=&gt;</span>  SELECT * FROM table WHERE i = <span class="num">5</span> AND j = <span class="num">8</span></pre><p>Approach used:
- Populate a mapping of attribute =&gt; constant value by looking at all the equals predicates
- Using this mapping, replace occurrence of the attributes with the corresponding constant values
  in the AND node.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ConvertToLocalRelation" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ConvertToLocalRelation"></a><a id="ConvertToLocalRelation:ConvertToLocalRelation"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ConvertToLocalRelation$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Converts local operations (i.e." href="ConvertToLocalRelation$.html"><span class="name">ConvertToLocalRelation</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Converts local operations (i.e.</p><div class="fullcomment"><div class="comment cmt"><p>Converts local operations (i.e. ones that don't require data exchange) on <code>LocalRelation</code> to
another <code>LocalRelation</code>.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.CostBasedJoinReorder" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="CostBasedJoinReorder"></a><a id="CostBasedJoinReorder:CostBasedJoinReorder"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/CostBasedJoinReorder$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Cost-based join reorder." href="CostBasedJoinReorder$.html"><span class="name">CostBasedJoinReorder</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Cost-based join reorder.</p><div class="fullcomment"><div class="comment cmt"><p>Cost-based join reorder.
We may have several join reorder algorithms in the future. This class is the entry of these
algorithms, and chooses which one to use.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.DecimalAggregates" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="DecimalAggregates"></a><a id="DecimalAggregates:DecimalAggregates"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/DecimalAggregates$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Speeds up aggregates on fixed-precision decimals by executing them on unscaled Long values." href="DecimalAggregates$.html"><span class="name">DecimalAggregates</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Speeds up aggregates on fixed-precision decimals by executing them on unscaled Long values.</p><div class="fullcomment"><div class="comment cmt"><p>Speeds up aggregates on fixed-precision decimals by executing them on unscaled Long values.</p><p>This uses the same rules for increasing the precision and scale of the output as
<a href="../analysis/DecimalPrecision$.html" class="extype" name="org.apache.spark.sql.catalyst.analysis.DecimalPrecision">org.apache.spark.sql.catalyst.analysis.DecimalPrecision</a>.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.DecorrelateInnerQuery" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="DecorrelateInnerQuery"></a><a id="DecorrelateInnerQuery:DecorrelateInnerQuery"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/DecorrelateInnerQuery$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Decorrelate the inner query by eliminating outer references and create domain joins." href="DecorrelateInnerQuery$.html"><span class="name">DecorrelateInnerQuery</span></a><span class="result"> extends <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Decorrelate the inner query by eliminating outer references and create domain joins.</p><div class="fullcomment"><div class="comment cmt"><p>Decorrelate the inner query by eliminating outer references and create domain joins.
The implementation is based on the paper: Unnesting Arbitrary Queries by Thomas Neumann
and Alfons Kemper. https://dl.gi.de/handle/20.500.12116/2418.</p><p>A correlated subquery can be viewed as a &quot;dependent&quot; nested loop join between the outer and
the inner query. For each row produced by the outer query, we bind the <span class="extype" name="OuterReference">OuterReference</span>s in
in the inner query with the corresponding values in the row, and then evaluate the inner query.</p><p>Dependent Join
:- Outer Query
+- Inner Query</p><p>If the <span class="extype" name="OuterReference">OuterReference</span>s are bound to the same value, the inner query will return the same
result. Based on this, we can reduce the times to evaluate the inner query by first getting
all distinct values of the <span class="extype" name="OuterReference">OuterReference</span>s.</p><p>Normal Join
:- Outer Query
+- Dependent Join
   :- Inner Query
   +- Distinct Aggregate (outer_ref1, outer_ref2, ...)
      +- Outer Query</p><p>The distinct aggregate of the outer references is called a &quot;domain&quot;, and the dependent join
between the inner query and the domain is called a &quot;domain join&quot;. We need to push down the
domain join through the inner query until there is no outer reference in the sub-tree and
the domain join will turn into a normal join.</p><p>The decorrelation function returns a new query plan with optional placeholder <span class="extype" name="DomainJoins">DomainJoins</span>s
added and a list of join conditions with the outer query. <span class="extype" name="DomainJoin">DomainJoin</span>s need to be rewritten
into actual inner join between the inner query sub-tree and the outer query.</p><p>E.g. decorrelate an inner query with equality predicates:</p><p>SELECT (SELECT MIN(b) FROM t1 WHERE t2.c = t1.a) FROM t2</p><p>Aggregate [] [min(b)]            Aggregate [a] [min(b), a]
+- Filter (outer(c) = a)   =&gt;   +- Relation [t1]
   +- Relation [t1]</p><p>Join conditions: [c = a]</p><p>E.g. decorrelate an inner query with non-equality predicates:</p><p>SELECT (SELECT MIN(b) FROM t1 WHERE t2.c &gt; t1.a) FROM t2</p><p>Aggregate [] [min(b)]            Aggregate [c'] [min(b), c']
+- Filter (outer(c) &gt; a)   =&gt;   +- Filter (c' &gt; a)
   +- Relation [t1]                  +- DomainJoin [c']
                                        +- Relation [t1]</p><p>Join conditions: [c &lt;=&gt; c']
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.EliminateAggregateFilter" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="EliminateAggregateFilter"></a><a id="EliminateAggregateFilter:EliminateAggregateFilter"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/EliminateAggregateFilter$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Remove useless FILTER clause for aggregate expressions." href="EliminateAggregateFilter$.html"><span class="name">EliminateAggregateFilter</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Remove useless FILTER clause for aggregate expressions.</p><div class="fullcomment"><div class="comment cmt"><p>Remove useless FILTER clause for aggregate expressions.
This rule should be applied before RewriteDistinctAggregates.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.EliminateDistinct" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="EliminateDistinct"></a><a id="EliminateDistinct:EliminateDistinct"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/EliminateDistinct$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Remove useless DISTINCT for MAX and MIN." href="EliminateDistinct$.html"><span class="name">EliminateDistinct</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Remove useless DISTINCT for MAX and MIN.</p><div class="fullcomment"><div class="comment cmt"><p>Remove useless DISTINCT for MAX and MIN.
This rule should be applied before RewriteDistinctAggregates.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.EliminateLimits" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="EliminateLimits"></a><a id="EliminateLimits:EliminateLimits"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/EliminateLimits$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="This rule optimizes Limit operators by: 1." href="EliminateLimits$.html"><span class="name">EliminateLimits</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">This rule optimizes Limit operators by:
1.</p><div class="fullcomment"><div class="comment cmt"><p>This rule optimizes Limit operators by:
1. Eliminate <span class="extype" name="Limit">Limit</span>/<span class="extype" name="GlobalLimit">GlobalLimit</span> operators if it's child max row &lt;= limit.
2. Combines two adjacent <span class="extype" name="Limit">Limit</span> operators into one, merging the
   expressions into one single expression.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.EliminateMapObjects" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="EliminateMapObjects"></a><a id="EliminateMapObjects:EliminateMapObjects"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/EliminateMapObjects$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Removes MapObjects when the following conditions are satisfied" href="EliminateMapObjects$.html"><span class="name">EliminateMapObjects</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Removes MapObjects when the following conditions are satisfied</p><div class="fullcomment"><div class="comment cmt"><p>Removes MapObjects when the following conditions are satisfied</p><ol class="decimal"><li>Mapobject(... lambdavariable(..., false) ...), which means types for input and output
     are primitive types with non-nullable
  2. no custom collection class specified representation of data item.
</li></ol></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.EliminateOuterJoin" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="EliminateOuterJoin"></a><a id="EliminateOuterJoin:EliminateOuterJoin"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/EliminateOuterJoin$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="1." href="EliminateOuterJoin$.html"><span class="name">EliminateOuterJoin</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">1.</p><div class="fullcomment"><div class="comment cmt"><p>1. Elimination of outer joins, if the predicates can restrict the result sets so that
all null-supplying rows are eliminated</p><p>- full outer -&gt; inner if both sides have such predicates
- left outer -&gt; inner if the right side has such predicates
- right outer -&gt; inner if the left side has such predicates
- full outer -&gt; left outer if only the left side has such predicates
- full outer -&gt; right outer if only the right side has such predicates</p><p>2. Removes outer join if it only has distinct on streamed side</p><pre>SELECT DISTINCT f1 FROM t1 LEFT JOIN t2 ON t1.id = t2.id  =<span class="kw">=&gt;</span>  SELECT DISTINCT f1 FROM t1</pre><p>This rule should be executed before pushing down the Filter
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.EliminateResolvedHint" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="EliminateResolvedHint"></a><a id="EliminateResolvedHint:EliminateResolvedHint"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/EliminateResolvedHint$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replaces ResolvedHint operators from the plan." href="EliminateResolvedHint$.html"><span class="name">EliminateResolvedHint</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replaces <span class="extype" name="ResolvedHint">ResolvedHint</span> operators from the plan.</p><div class="fullcomment"><div class="comment cmt"><p>Replaces <span class="extype" name="ResolvedHint">ResolvedHint</span> operators from the plan. Move the <span class="extype" name="HintInfo">HintInfo</span> to associated <span class="extype" name="Join">Join</span>
operators, otherwise remove it if no <span class="extype" name="Join">Join</span> operator is matched.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.EliminateSerialization" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="EliminateSerialization"></a><a id="EliminateSerialization:EliminateSerialization"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/EliminateSerialization$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Removes cases where we are unnecessarily going between the object and serialized (InternalRow) representation of data item." href="EliminateSerialization$.html"><span class="name">EliminateSerialization</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Removes cases where we are unnecessarily going between the object and serialized (InternalRow)
representation of data item.</p><div class="fullcomment"><div class="comment cmt"><p>Removes cases where we are unnecessarily going between the object and serialized (InternalRow)
representation of data item.  For example back to back map operations.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.EliminateSorts" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="EliminateSorts"></a><a id="EliminateSorts:EliminateSorts"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/EliminateSorts$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Removes Sort operations if they don't affect the final output ordering." href="EliminateSorts$.html"><span class="name">EliminateSorts</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Removes Sort operations if they don't affect the final output ordering.</p><div class="fullcomment"><div class="comment cmt"><p>Removes Sort operations if they don't affect the final output ordering.
Note that changes in the final output ordering may affect the file size (SPARK-32318).
This rule handles the following cases:
1) if the child maximum number of rows less than or equal to 1
2) if the sort order is empty or the sort order does not have any reference
3) if the Sort operator is a local sort and the child is already sorted
4) if there is another Sort operator separated by 0...n Project, Filter, Repartition or
   RepartitionByExpression (with deterministic expressions) operators
5) if the Sort operator is within Join separated by 0...n Project, Filter, Repartition or
   RepartitionByExpression (with deterministic expressions) operators only and the Join condition
   is deterministic
6) if the Sort operator is within GroupBy separated by 0...n Project, Filter, Repartition or
   RepartitionByExpression (with deterministic expressions) operators only and the aggregate
   function is order irrelevant
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ExtractPythonUDFFromJoinCondition" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ExtractPythonUDFFromJoinCondition"></a><a id="ExtractPythonUDFFromJoinCondition:ExtractPythonUDFFromJoinCondition"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ExtractPythonUDFFromJoinCondition$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="PythonUDF in join condition can't be evaluated if it refers to attributes from both join sides." href="ExtractPythonUDFFromJoinCondition$.html"><span class="name">ExtractPythonUDFFromJoinCondition</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">PythonUDF in join condition can't be evaluated if it refers to attributes from both join sides.</p><div class="fullcomment"><div class="comment cmt"><p>PythonUDF in join condition can't be evaluated if it refers to attributes from both join sides.
See <code>ExtractPythonUDFs</code> for details. This rule will detect un-evaluable PythonUDF and pull them
out from join condition.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.FoldablePropagation" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FoldablePropagation"></a><a id="FoldablePropagation:FoldablePropagation"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/FoldablePropagation$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replace attributes with aliases of the original foldable expressions if possible." href="FoldablePropagation$.html"><span class="name">FoldablePropagation</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replace attributes with aliases of the original foldable expressions if possible.</p><div class="fullcomment"><div class="comment cmt"><p>Replace attributes with aliases of the original foldable expressions if possible.
Other optimizations will take advantage of the propagated foldable expressions. For example,
this rule can optimize</p><pre>SELECT <span class="num">1.0</span> x, <span class="lit">'abc'</span> y, Now() z ORDER BY x, y, <span class="num">3</span></pre><p>to</p><pre>SELECT <span class="num">1.0</span> x, <span class="lit">'abc'</span> y, Now() z ORDER BY <span class="num">1.0</span>, <span class="lit">'abc'</span>, Now()</pre><p>and other rules can further optimize it and remove the ORDER BY operator.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.GeneratorNestedColumnAliasing" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="GeneratorNestedColumnAliasing"></a><a id="GeneratorNestedColumnAliasing:GeneratorNestedColumnAliasing"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/GeneratorNestedColumnAliasing$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="This prunes unnecessary nested columns from Generate, or Project -&gt; Generate" href="GeneratorNestedColumnAliasing$.html"><span class="name">GeneratorNestedColumnAliasing</span></a>
      </span>
      
      <p class="shortcomment cmt">This prunes unnecessary nested columns from <span class="extype" name="Generate">Generate</span>, or <span class="extype" name="Project">Project</span> -&gt; <span class="extype" name="Generate">Generate</span>
</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.InferFiltersFromConstraints" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="InferFiltersFromConstraints"></a><a id="InferFiltersFromConstraints:InferFiltersFromConstraints"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/InferFiltersFromConstraints$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Generate a list of additional filters from an operator's existing constraint but remove those that are either already part of the operator's condition or are part of the operator's child constraints." href="InferFiltersFromConstraints$.html"><span class="name">InferFiltersFromConstraints</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a> with <a href="../plans/logical/ConstraintHelper.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.ConstraintHelper">ConstraintHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Generate a list of additional filters from an operator's existing constraint but remove those
that are either already part of the operator's condition or are part of the operator's child
constraints.</p><div class="fullcomment"><div class="comment cmt"><p>Generate a list of additional filters from an operator's existing constraint but remove those
that are either already part of the operator's condition or are part of the operator's child
constraints. These filters are currently inserted to the existing conditions in the Filter
operators and on either side of Join operators.</p><p>Note: While this optimization is applicable to a lot of types of join, it primarily benefits
Inner and LeftSemi joins.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.InferFiltersFromGenerate" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="InferFiltersFromGenerate"></a><a id="InferFiltersFromGenerate:InferFiltersFromGenerate"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/InferFiltersFromGenerate$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Infers filters from Generate, such that rows that would have been removed by this Generate can be removed earlier - before joins and in data sources." href="InferFiltersFromGenerate$.html"><span class="name">InferFiltersFromGenerate</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Infers filters from <span class="extype" name="Generate">Generate</span>, such that rows that would have been removed
by this <span class="extype" name="Generate">Generate</span> can be removed earlier - before joins and in data sources.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.InlineCTE" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="InlineCTE"></a><a id="InlineCTE:InlineCTE"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/InlineCTE$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Inlines CTE definitions into corresponding references if either of the conditions satisfies: 1." href="InlineCTE$.html"><span class="name">InlineCTE</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Inlines CTE definitions into corresponding references if either of the conditions satisfies:
1.</p><div class="fullcomment"><div class="comment cmt"><p>Inlines CTE definitions into corresponding references if either of the conditions satisfies:
1. The CTE definition does not contain any non-deterministic expressions. If this CTE
   definition references another CTE definition that has non-deterministic expressions, it
   is still OK to inline the current CTE definition.
2. The CTE definition is only referenced once throughout the main query and all the subqueries.</p><p>In addition, due to the complexity of correlated subqueries, all CTE references in correlated
subqueries are inlined regardless of the conditions above.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.JoinReorderDP" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="JoinReorderDP"></a><a id="JoinReorderDP:JoinReorderDP"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/JoinReorderDP$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Reorder the joins using a dynamic programming algorithm." href="JoinReorderDP$.html"><span class="name">JoinReorderDP</span></a><span class="result"> extends <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a> with <span class="extype" name="org.apache.spark.internal.Logging">Logging</span></span>
      </span>
      
      <p class="shortcomment cmt">Reorder the joins using a dynamic programming algorithm.</p><div class="fullcomment"><div class="comment cmt"><p>Reorder the joins using a dynamic programming algorithm. This implementation is based on the
paper: Access Path Selection in a Relational Database Management System.
https://dl.acm.org/doi/10.1145/582095.582099</p><p>First we put all items (basic joined nodes) into level 0, then we build all two-way joins
at level 1 from plans at level 0 (single items), then build all 3-way joins from plans
at previous levels (two-way joins and single items), then 4-way joins ... etc, until we
build all n-way joins and pick the best plan among them.</p><p>When building m-way joins, we only keep the best plan (with the lowest cost) for the same set
of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among
plans (A J B) J C, (A J C) J B and (B J C) J A.
We also prune cartesian product candidates when building a new plan if there exists no join
condition involving references from both left and right. This pruning strategy significantly
reduces the search space.
E.g., given A J B J C J D with join conditions A.k1 = B.k1 and B.k2 = C.k2 and C.k3 = D.k3,
plans maintained for each level are as follows:
level 0: p({A}), p({B}), p({C}), p({D})
level 1: p({A, B}), p({B, C}), p({C, D})
level 2: p({A, B, C}), p({B, C, D})
level 3: p({A, B, C, D})
where p({A, B, C, D}) is the final output plan.</p><p>For cost evaluation, since physical costs for operators are not available currently, we use
cardinalities and sizes to compute costs.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.JoinReorderDPFilters" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="JoinReorderDPFilters"></a><a id="JoinReorderDPFilters:JoinReorderDPFilters"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/JoinReorderDPFilters$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Implements optional filters to reduce the search space for join enumeration." href="JoinReorderDPFilters$.html"><span class="name">JoinReorderDPFilters</span></a><span class="result"> extends <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Implements optional filters to reduce the search space for join enumeration.</p><div class="fullcomment"><div class="comment cmt"><p>Implements optional filters to reduce the search space for join enumeration.</p><p>1) Star-join filters: Plan star-joins together since they are assumed
   to have an optimal execution based on their RI relationship.
2) Cartesian products: Defer their planning later in the graph to avoid
   large intermediate results (expanding joins, in general).
3) Composite inners: Don't generate &quot;bushy tree&quot; plans to avoid materializing
  intermediate results.</p><p>Filters (2) and (3) are not implemented.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.LikeSimplification" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="LikeSimplification"></a><a id="LikeSimplification:LikeSimplification"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/LikeSimplification$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Simplifies LIKE expressions that do not need full regular expressions to evaluate the condition." href="LikeSimplification$.html"><span class="name">LikeSimplification</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Simplifies LIKE expressions that do not need full regular expressions to evaluate the condition.</p><div class="fullcomment"><div class="comment cmt"><p>Simplifies LIKE expressions that do not need full regular expressions to evaluate the condition.
For example, when the expression is just checking to see if a string starts with a given
pattern.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.LimitPushDown" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="LimitPushDown"></a><a id="LimitPushDown:LimitPushDown"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/LimitPushDown$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Pushes down LocalLimit beneath UNION ALL and joins." href="LimitPushDown$.html"><span class="name">LimitPushDown</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Pushes down <span class="extype" name="LocalLimit">LocalLimit</span> beneath UNION ALL and joins.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.LimitPushDownThroughWindow" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="LimitPushDownThroughWindow"></a><a id="LimitPushDownThroughWindow:LimitPushDownThroughWindow"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/LimitPushDownThroughWindow$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Pushes down LocalLimit beneath WINDOW." href="LimitPushDownThroughWindow$.html"><span class="name">LimitPushDownThroughWindow</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Pushes down <span class="extype" name="LocalLimit">LocalLimit</span> beneath WINDOW.</p><div class="fullcomment"><div class="comment cmt"><p>Pushes down <span class="extype" name="LocalLimit">LocalLimit</span> beneath WINDOW. This rule optimizes the following case:</p><pre>SELECT *, ROW_NUMBER() OVER(ORDER BY a) AS rn FROM Tab1 LIMIT <span class="num">5</span> =<span class="kw">=&gt;</span>
SELECT *, ROW_NUMBER() OVER(ORDER BY a) AS rn FROM (SELECT * FROM Tab1 ORDER BY a LIMIT <span class="num">5</span>) t</pre></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.NestedColumnAliasing" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="NestedColumnAliasing"></a><a id="NestedColumnAliasing:NestedColumnAliasing"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/NestedColumnAliasing$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="This aims to handle a nested column aliasing pattern inside the ColumnPruning optimizer rule." href="NestedColumnAliasing$.html"><span class="name">NestedColumnAliasing</span></a>
      </span>
      
      <p class="shortcomment cmt">This aims to handle a nested column aliasing pattern inside the <a href="ColumnPruning$.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.ColumnPruning">ColumnPruning</a> optimizer rule.</p><div class="fullcomment"><div class="comment cmt"><p>This aims to handle a nested column aliasing pattern inside the <a href="ColumnPruning$.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.ColumnPruning">ColumnPruning</a> optimizer rule.
If:
- A <span class="extype" name="Project">Project</span> or its child references nested fields
- Not all of the fields in a nested attribute are used
Then:
- Substitute the nested field references with alias attributes
- Add grandchild <span class="extype" name="Project">Project</span>s transforming the nested fields to aliases</p><p>Example 1: Project
------------------
Before:
+- Project [concat_ws(s#0.a, s#0.b) AS concat_ws(s.a, s.b)#1]
  +- GlobalLimit 5
    +- LocalLimit 5
      +- LocalRelation &lt;empty&gt;, [s#0]
After:
+- Project [concat_ws(_extract_a#2, _extract_b#3) AS concat_ws(s.a, s.b)#1]
  +- GlobalLimit 5
    +- LocalLimit 5
      +- Project [s#0.a AS _extract_a#2, s#0.b AS _extract_b#3]
        +- LocalRelation &lt;empty&gt;, [s#0]</p><p>Example 2: Project above Filter
-------------------------------
Before:
+- Project [s#0.a AS s.a#1]
  +- Filter (length(s#0.b) &gt; 2)
    +- GlobalLimit 5
      +- LocalLimit 5
        +- LocalRelation &lt;empty&gt;, [s#0]
After:
+- Project [_extract_a#2 AS s.a#1]
  +- Filter (length(_extract_b#3) &gt; 2)
    +- GlobalLimit 5
      +- LocalLimit 5
        +- Project [s#0.a AS _extract_a#2, s#0.b AS _extract_b#3]
          +- LocalRelation &lt;empty&gt;, [s#0]</p><p>Example 3: Nested fields with referenced parents
------------------------------------------------
Before:
+- Project [s#0.a AS s.a#1, s#0.a.a1 AS s.a.a1#2]
  +- GlobalLimit 5
    +- LocalLimit 5
      +- LocalRelation &lt;empty&gt;, [s#0]
After:
+- Project [_extract_a#3 AS s.a#1, _extract_a#3.name AS s.a.a1#2]
  +- GlobalLimit 5
    +- LocalLimit 5
      +- Project [s#0.a AS _extract_a#3]
        +- LocalRelation &lt;empty&gt;, [s#0]</p><p>The schema of the datasource relation will be pruned in the <span class="extype" name="SchemaPruning">SchemaPruning</span> optimizer rule.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.NormalizeFloatingNumbers" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="NormalizeFloatingNumbers"></a><a id="NormalizeFloatingNumbers:NormalizeFloatingNumbers"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/NormalizeFloatingNumbers$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="We need to take care of special floating numbers (NaN and -0.0) in several places:" href="NormalizeFloatingNumbers$.html"><span class="name">NormalizeFloatingNumbers</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">We need to take care of special floating numbers (NaN and -0.0) in several places:</p><div class="fullcomment"><div class="comment cmt"><p>We need to take care of special floating numbers (NaN and -0.0) in several places:</p><ol class="decimal"><li>When compare values, different NaNs should be treated as same, <code>-0.0</code> and <code>0.0</code> should be
     treated as same.
  2. In aggregate grouping keys, different NaNs should belong to the same group, -0.0 and 0.0
     should belong to the same group.
  3. In join keys, different NaNs should be treated as same, <code>-0.0</code> and <code>0.0</code> should be
     treated as same.
  4. In window partition keys, different NaNs should belong to the same partition, -0.0 and 0.0
     should belong to the same partition.</li></ol><p>Case 1 is fine, as we handle NaN and -0.0 well during comparison. For complex types, we
recursively compare the fields/elements, so it's also fine.</p><p>Case 2, 3 and 4 are problematic, as Spark SQL turns grouping/join/window partition keys into
binary <code>UnsafeRow</code> and compare the binary data directly. Different NaNs have different binary
representation, and the same thing happens for -0.0 and 0.0.</p><p>This rule normalizes NaN and -0.0 in window partition keys, join keys and aggregate grouping
keys.</p><p>Ideally we should do the normalization in the physical operators that compare the
binary <code>UnsafeRow</code> directly. We don't need this normalization if the Spark SQL execution engine
is not optimized to run on binary data. This rule is created to simplify the implementation, so
that we have a single place to do normalization, which is more maintainable.</p><p>Note that, this rule must be executed at the end of optimizer, because the optimizer may create
new joins(the subquery rewrite) and new join conditions(the join reorder).
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.NullPropagation" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="NullPropagation"></a><a id="NullPropagation:NullPropagation"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/NullPropagation$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replaces Expressions that can be statically evaluated with equivalent Literal values." href="NullPropagation$.html"><span class="name">NullPropagation</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replaces <span class="extype" name="Expression">Expressions</span> that can be statically evaluated with
equivalent <span class="extype" name="Literal">Literal</span> values.</p><div class="fullcomment"><div class="comment cmt"><p>Replaces <span class="extype" name="Expression">Expressions</span> that can be statically evaluated with
equivalent <span class="extype" name="Literal">Literal</span> values. This rule is more specific with
Null value propagation from bottom to top of the expression tree.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ObjectSerializerPruning" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ObjectSerializerPruning"></a><a id="ObjectSerializerPruning:ObjectSerializerPruning"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ObjectSerializerPruning$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Prunes unnecessary object serializers from query plan." href="ObjectSerializerPruning$.html"><span class="name">ObjectSerializerPruning</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Prunes unnecessary object serializers from query plan.</p><div class="fullcomment"><div class="comment cmt"><p>Prunes unnecessary object serializers from query plan. This rule prunes both individual
serializer and nested fields in serializers.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.OptimizeCsvJsonExprs" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="OptimizeCsvJsonExprs"></a><a id="OptimizeCsvJsonExprs:OptimizeCsvJsonExprs"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/OptimizeCsvJsonExprs$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Simplify redundant csv/json related expressions." href="OptimizeCsvJsonExprs$.html"><span class="name">OptimizeCsvJsonExprs</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Simplify redundant csv/json related expressions.</p><div class="fullcomment"><div class="comment cmt"><p>Simplify redundant csv/json related expressions.</p><p>The optimization includes:
1. JsonToStructs(StructsToJson(child)) =&gt; child.
2. Prune unnecessary columns from GetStructField/GetArrayStructFields + JsonToStructs.
3. CreateNamedStruct(JsonToStructs(json).col1, JsonToStructs(json).col2, ...) =&gt;
     If(IsNull(json), nullStruct, KnownNotNull(JsonToStructs(prunedSchema, ..., json)))
     if JsonToStructs(json) is shared among all fields of CreateNamedStruct. <code>prunedSchema</code>
     contains all accessed fields in original CreateNamedStruct.
4. Prune unnecessary columns from GetStructField + CsvToStructs.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.OptimizeIn" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="OptimizeIn"></a><a id="OptimizeIn:OptimizeIn"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/OptimizeIn$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Optimize IN predicates: 1." href="OptimizeIn$.html"><span class="name">OptimizeIn</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Optimize IN predicates:
1.</p><div class="fullcomment"><div class="comment cmt"><p>Optimize IN predicates:
1. Converts the predicate to false when the list is empty and
   the value is not nullable.
2. Removes literal repetitions.
3. Replaces <span class="extype" name="In">(value, seq[Literal])</span> with optimized version
   <span class="extype" name="InSet">(value, HashSet[Literal])</span> which is much faster.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.OptimizeLimitZero" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="OptimizeLimitZero"></a><a id="OptimizeLimitZero:OptimizeLimitZero"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/OptimizeLimitZero$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replaces GlobalLimit 0 and LocalLimit 0 nodes (subtree) with empty Local Relation, as they don't return any rows." href="OptimizeLimitZero$.html"><span class="name">OptimizeLimitZero</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replaces GlobalLimit 0 and LocalLimit 0 nodes (subtree) with empty Local Relation, as they don't
return any rows.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.OptimizeOneRowRelationSubquery" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="OptimizeOneRowRelationSubquery"></a><a id="OptimizeOneRowRelationSubquery:OptimizeOneRowRelationSubquery"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/OptimizeOneRowRelationSubquery$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="This rule optimizes subqueries with OneRowRelation as leaf nodes." href="OptimizeOneRowRelationSubquery$.html"><span class="name">OptimizeOneRowRelationSubquery</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">This rule optimizes subqueries with OneRowRelation as leaf nodes.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.OptimizeRepartition" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="OptimizeRepartition"></a><a id="OptimizeRepartition:OptimizeRepartition"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/OptimizeRepartition$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replace RepartitionByExpression numPartitions to 1 if all partition expressions are foldable and user not specify." href="OptimizeRepartition$.html"><span class="name">OptimizeRepartition</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replace RepartitionByExpression numPartitions to 1 if all partition expressions are foldable
and user not specify.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.OptimizeUpdateFields" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="OptimizeUpdateFields"></a><a id="OptimizeUpdateFields:OptimizeUpdateFields"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/OptimizeUpdateFields$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Optimizes UpdateFields expression chains." href="OptimizeUpdateFields$.html"><span class="name">OptimizeUpdateFields</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Optimizes <span class="extype" name="UpdateFields">UpdateFields</span> expression chains.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.OptimizeWindowFunctions" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="OptimizeWindowFunctions"></a><a id="OptimizeWindowFunctions:OptimizeWindowFunctions"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/OptimizeWindowFunctions$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replaces first(col) to nth_value(col, 1) for better performance." href="OptimizeWindowFunctions$.html"><span class="name">OptimizeWindowFunctions</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replaces first(col) to nth_value(col, 1) for better performance.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.PropagateEmptyRelation" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PropagateEmptyRelation"></a><a id="PropagateEmptyRelation:PropagateEmptyRelation"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/PropagateEmptyRelation$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="This rule runs in the normal optimizer and optimizes more cases compared to PropagateEmptyRelationBase: 1." href="PropagateEmptyRelation$.html"><span class="name">PropagateEmptyRelation</span></a><span class="result"> extends <a href="PropagateEmptyRelationBase.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.PropagateEmptyRelationBase">PropagateEmptyRelationBase</a></span>
      </span>
      
      <p class="shortcomment cmt">This rule runs in the normal optimizer and optimizes more cases
compared to <a href="PropagateEmptyRelationBase.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.PropagateEmptyRelationBase">PropagateEmptyRelationBase</a>:
1.</p><div class="fullcomment"><div class="comment cmt"><p>This rule runs in the normal optimizer and optimizes more cases
compared to <a href="PropagateEmptyRelationBase.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.PropagateEmptyRelationBase">PropagateEmptyRelationBase</a>:
1. Higher-node Logical Plans</p><ul><li>Union with all empty children.
2. Unary-node Logical Plans</li><li>Project/Filter/Sample with all empty children.</li></ul><p>The reason why we don't apply this rule at AQE optimizer side is: the benefit is not big enough
and it may introduce extra exchanges.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.PruneFilters" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PruneFilters"></a><a id="PruneFilters:PruneFilters"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/PruneFilters$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Removes filters that can be evaluated trivially." href="PruneFilters$.html"><span class="name">PruneFilters</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Removes filters that can be evaluated trivially.</p><div class="fullcomment"><div class="comment cmt"><p>Removes filters that can be evaluated trivially.  This can be done through the following ways:
1) by eliding the filter for cases where it will always evaluate to <code>true</code>.
2) by substituting a dummy empty relation when the filter will always evaluate to <code>false</code>.
3) by eliminating the always-true conditions given the constraints on the child's output.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.PullOutGroupingExpressions" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PullOutGroupingExpressions"></a><a id="PullOutGroupingExpressions:PullOutGroupingExpressions"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/PullOutGroupingExpressions$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="This rule ensures that Aggregate nodes doesn't contain complex grouping expressions in the optimization phase." href="PullOutGroupingExpressions$.html"><span class="name">PullOutGroupingExpressions</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">This rule ensures that <span class="extype" name="Aggregate">Aggregate</span> nodes doesn't contain complex grouping expressions in the
optimization phase.</p><div class="fullcomment"><div class="comment cmt"><p>This rule ensures that <span class="extype" name="Aggregate">Aggregate</span> nodes doesn't contain complex grouping expressions in the
optimization phase.</p><p>Complex grouping expressions are pulled out to a <span class="extype" name="Project">Project</span> node under <span class="extype" name="Aggregate">Aggregate</span> and are
referenced in both grouping expressions and aggregate expressions without aggregate functions.
These references ensure that optimization rules don't change the aggregate expressions to invalid
ones that no longer refer to any grouping expressions and also simplify the expression
transformations on the node (need to transform the expression only once).</p><p>For example, in the following query Spark shouldn't optimize the aggregate expression
<code>Not(IsNull(c))</code> to <code>IsNotNull(c)</code> as the grouping expression is <code>IsNull(c)</code>:
SELECT not(c IS NULL)
FROM t
GROUP BY c IS NULL
Instead, the aggregate expression references a <code>_groupingexpression</code> attribute:
Aggregate [_groupingexpression#233], [NOT _groupingexpression#233 AS (NOT (c IS NULL))#230]
+- Project [isnull(c#219) AS _groupingexpression#233]
   +- LocalRelation [c#219]
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.PullupCorrelatedPredicates" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PullupCorrelatedPredicates"></a><a id="PullupCorrelatedPredicates:PullupCorrelatedPredicates"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/PullupCorrelatedPredicates$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Pull out all (outer) correlated predicates from a given subquery." href="PullupCorrelatedPredicates$.html"><span class="name">PullupCorrelatedPredicates</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Pull out all (outer) correlated predicates from a given subquery.</p><div class="fullcomment"><div class="comment cmt"><p>Pull out all (outer) correlated predicates from a given subquery. This method removes the
correlated predicates from subquery <span class="extype" name="Filter">Filter</span>s and adds the references of these predicates
to all intermediate <span class="extype" name="Project">Project</span> and <span class="extype" name="Aggregate">Aggregate</span> clauses (if they are missing) in order to
be able to evaluate the predicates at the top level.</p><p>TODO: Look to merge this rule with RewritePredicateSubquery.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.PushDownLeftSemiAntiJoin" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PushDownLeftSemiAntiJoin"></a><a id="PushDownLeftSemiAntiJoin:PushDownLeftSemiAntiJoin"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/PushDownLeftSemiAntiJoin$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="This rule is a variant of PushPredicateThroughNonJoin which can handle pushing down Left semi and Left Anti joins below the following operators." href="PushDownLeftSemiAntiJoin$.html"><span class="name">PushDownLeftSemiAntiJoin</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a> with <a href="JoinSelectionHelper.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.JoinSelectionHelper">JoinSelectionHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">This rule is a variant of <a href="PushPredicateThroughNonJoin$.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.PushPredicateThroughNonJoin">PushPredicateThroughNonJoin</a> which can handle
pushing down Left semi and Left Anti joins below the following operators.</p><div class="fullcomment"><div class="comment cmt"><p>This rule is a variant of <a href="PushPredicateThroughNonJoin$.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.PushPredicateThroughNonJoin">PushPredicateThroughNonJoin</a> which can handle
pushing down Left semi and Left Anti joins below the following operators.
 1) Project
 2) Window
 3) Union
 4) Aggregate
 5) Other permissible unary operators. please see <a href="PushPredicateThroughNonJoin$.html#canPushThrough(p:org.apache.spark.sql.catalyst.plans.logical.UnaryNode):Boolean" class="extmbr" name="org.apache.spark.sql.catalyst.optimizer.PushPredicateThroughNonJoin#canPushThrough">PushPredicateThroughNonJoin.canPushThrough</a>.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.PushDownPredicates" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PushDownPredicates"></a><a id="PushDownPredicates:PushDownPredicates"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/PushDownPredicates$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="The unified version for predicate pushdown of normal operators and joins." href="PushDownPredicates$.html"><span class="name">PushDownPredicates</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">The unified version for predicate pushdown of normal operators and joins.</p><div class="fullcomment"><div class="comment cmt"><p>The unified version for predicate pushdown of normal operators and joins.
This rule improves performance of predicate pushdown for cascading joins such as:
 Filter-Join-Join-Join. Most predicates can be pushed down in a single pass.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.PushExtraPredicateThroughJoin" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PushExtraPredicateThroughJoin"></a><a id="PushExtraPredicateThroughJoin:PushExtraPredicateThroughJoin"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/PushExtraPredicateThroughJoin$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Try pushing down disjunctive join condition into left and right child." href="PushExtraPredicateThroughJoin$.html"><span class="name">PushExtraPredicateThroughJoin</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Try pushing down disjunctive join condition into left and right child.</p><div class="fullcomment"><div class="comment cmt"><p>Try pushing down disjunctive join condition into left and right child.
To avoid expanding the join condition, the join condition will be kept in the original form even
when predicate pushdown happens.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.PushFoldableIntoBranches" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="PushFoldableIntoBranches"></a><a id="PushFoldableIntoBranches:PushFoldableIntoBranches"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/PushFoldableIntoBranches$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Push the foldable expression into (if / case) branches." href="PushFoldableIntoBranches$.html"><span class="name">PushFoldableIntoBranches</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Push the foldable expression into (if / case) branches.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.PushLeftSemiLeftAntiThroughJoin" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PushLeftSemiLeftAntiThroughJoin"></a><a id="PushLeftSemiLeftAntiThroughJoin:PushLeftSemiLeftAntiThroughJoin"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/PushLeftSemiLeftAntiThroughJoin$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="This rule is a variant of PushPredicateThroughJoin which can handle pushing down Left semi and Left Anti joins below a join operator." href="PushLeftSemiLeftAntiThroughJoin$.html"><span class="name">PushLeftSemiLeftAntiThroughJoin</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">This rule is a variant of <a href="PushPredicateThroughJoin$.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.PushPredicateThroughJoin">PushPredicateThroughJoin</a> which can handle
pushing down Left semi and Left Anti joins below a join operator.</p><div class="fullcomment"><div class="comment cmt"><p>This rule is a variant of <a href="PushPredicateThroughJoin$.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.PushPredicateThroughJoin">PushPredicateThroughJoin</a> which can handle
pushing down Left semi and Left Anti joins below a join operator. The
allowable join types are:
 1) Inner
 2) Cross
 3) LeftOuter
 4) RightOuter</p><p>TODO:
Currently this rule can push down the left semi or left anti joins to either
left or right leg of the child join. This matches the behaviour of <code>PushPredicateThroughJoin</code>
when the left semi or left anti join is in expression form. We need to explore the possibility
to push the left semi/anti joins to both legs of join if the join condition refers to
both left and right legs of the child join.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.PushPredicateThroughJoin" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PushPredicateThroughJoin"></a><a id="PushPredicateThroughJoin:PushPredicateThroughJoin"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/PushPredicateThroughJoin$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Pushes down Filter operators where the condition can be evaluated using only the attributes of the left or right side of a join." href="PushPredicateThroughJoin$.html"><span class="name">PushPredicateThroughJoin</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Pushes down <span class="extype" name="Filter">Filter</span> operators where the <code>condition</code> can be
evaluated using only the attributes of the left or right side of a join.</p><div class="fullcomment"><div class="comment cmt"><p>Pushes down <span class="extype" name="Filter">Filter</span> operators where the <code>condition</code> can be
evaluated using only the attributes of the left or right side of a join.  Other
<span class="extype" name="Filter">Filter</span> conditions are moved into the <code>condition</code> of the <span class="extype" name="Join">Join</span>.</p><p>And also pushes down the join filter, where the <code>condition</code> can be evaluated using only the
attributes of the left or right side of sub query when applicable.</p><p>Check https://cwiki.apache.org/confluence/display/Hive/OuterJoinBehavior for more details
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.PushPredicateThroughNonJoin" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PushPredicateThroughNonJoin"></a><a id="PushPredicateThroughNonJoin:PushPredicateThroughNonJoin"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/PushPredicateThroughNonJoin$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Pushes Filter operators through many operators iff: 1) the operator is deterministic 2) the predicate is deterministic and the operator will not change any of rows." href="PushPredicateThroughNonJoin$.html"><span class="name">PushPredicateThroughNonJoin</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Pushes <span class="extype" name="Filter">Filter</span> operators through many operators iff:
1) the operator is deterministic
2) the predicate is deterministic and the operator will not change any of rows.</p><div class="fullcomment"><div class="comment cmt"><p>Pushes <span class="extype" name="Filter">Filter</span> operators through many operators iff:
1) the operator is deterministic
2) the predicate is deterministic and the operator will not change any of rows.</p><p>This heuristic is valid assuming the expression evaluation cost is minimal.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.PushProjectionThroughUnion" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PushProjectionThroughUnion"></a><a id="PushProjectionThroughUnion:PushProjectionThroughUnion"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/PushProjectionThroughUnion$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Pushes Project operator to both sides of a Union operator." href="PushProjectionThroughUnion$.html"><span class="name">PushProjectionThroughUnion</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Pushes Project operator to both sides of a Union operator.</p><div class="fullcomment"><div class="comment cmt"><p>Pushes Project operator to both sides of a Union operator.
Operations that are safe to pushdown are listed as follows.
Union:
Right now, Union means UNION ALL, which does not de-duplicate rows. So, it is
safe to pushdown Filters and Projections through it. Filter pushdown is handled by another
rule PushDownPredicates. Once we add UNION DISTINCT, we will not be able to pushdown Projections.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ReassignLambdaVariableID" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ReassignLambdaVariableID"></a><a id="ReassignLambdaVariableID:ReassignLambdaVariableID"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ReassignLambdaVariableID$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Reassigns per-query unique IDs to LambdaVariables, whose original IDs are globally unique." href="ReassignLambdaVariableID$.html"><span class="name">ReassignLambdaVariableID</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Reassigns per-query unique IDs to <code>LambdaVariable</code>s, whose original IDs are globally unique.</p><div class="fullcomment"><div class="comment cmt"><p>Reassigns per-query unique IDs to <code>LambdaVariable</code>s, whose original IDs are globally unique. This
can help Spark to hit codegen cache more often and improve performance.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RemoveDispensableExpressions" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="RemoveDispensableExpressions"></a><a id="RemoveDispensableExpressions:RemoveDispensableExpressions"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RemoveDispensableExpressions$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Removes nodes that are not necessary." href="RemoveDispensableExpressions$.html"><span class="name">RemoveDispensableExpressions</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Removes nodes that are not necessary.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RemoveLiteralFromGroupExpressions" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="RemoveLiteralFromGroupExpressions"></a><a id="RemoveLiteralFromGroupExpressions:RemoveLiteralFromGroupExpressions"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RemoveLiteralFromGroupExpressions$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Removes literals from group expressions in Aggregate, as they have no effect to the result but only makes the grouping key bigger." href="RemoveLiteralFromGroupExpressions$.html"><span class="name">RemoveLiteralFromGroupExpressions</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Removes literals from group expressions in <span class="extype" name="Aggregate">Aggregate</span>, as they have no effect to the result
but only makes the grouping key bigger.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RemoveNoopOperators" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="RemoveNoopOperators"></a><a id="RemoveNoopOperators:RemoveNoopOperators"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RemoveNoopOperators$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Remove no-op operators from the query plan that do not make any modifications." href="RemoveNoopOperators$.html"><span class="name">RemoveNoopOperators</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Remove no-op operators from the query plan that do not make any modifications.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RemoveNoopUnion" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="RemoveNoopUnion"></a><a id="RemoveNoopUnion:RemoveNoopUnion"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RemoveNoopUnion$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Smplify the children of Union or remove no-op Union from the query plan that do not make any modifications to the query." href="RemoveNoopUnion$.html"><span class="name">RemoveNoopUnion</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Smplify the children of <code>Union</code> or remove no-op <code>Union</code> from the query plan that
do not make any modifications to the query.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RemoveRedundantAggregates" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RemoveRedundantAggregates"></a><a id="RemoveRedundantAggregates:RemoveRedundantAggregates"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RemoveRedundantAggregates$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Remove redundant aggregates from a query plan." href="RemoveRedundantAggregates$.html"><span class="name">RemoveRedundantAggregates</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/AliasHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.AliasHelper">AliasHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Remove redundant aggregates from a query plan.</p><div class="fullcomment"><div class="comment cmt"><p>Remove redundant aggregates from a query plan. A redundant aggregate is an aggregate whose
only goal is to keep distinct values, while its parent aggregate would ignore duplicate values.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RemoveRedundantAliases" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RemoveRedundantAliases"></a><a id="RemoveRedundantAliases:RemoveRedundantAliases"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RemoveRedundantAliases$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Remove redundant aliases from a query plan." href="RemoveRedundantAliases$.html"><span class="name">RemoveRedundantAliases</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Remove redundant aliases from a query plan.</p><div class="fullcomment"><div class="comment cmt"><p>Remove redundant aliases from a query plan. A redundant alias is an alias that does not change
the name or metadata of a column, and does not deduplicate it.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RemoveRepetitionFromGroupExpressions" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="RemoveRepetitionFromGroupExpressions"></a><a id="RemoveRepetitionFromGroupExpressions:RemoveRepetitionFromGroupExpressions"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RemoveRepetitionFromGroupExpressions$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Removes repetition from group expressions in Aggregate, as they have no effect to the result but only makes the grouping key bigger." href="RemoveRepetitionFromGroupExpressions$.html"><span class="name">RemoveRepetitionFromGroupExpressions</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Removes repetition from group expressions in <span class="extype" name="Aggregate">Aggregate</span>, as they have no effect to the result
but only makes the grouping key bigger.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ReorderAssociativeOperator" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ReorderAssociativeOperator"></a><a id="ReorderAssociativeOperator:ReorderAssociativeOperator"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ReorderAssociativeOperator$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Reorder associative integral-type operators and fold all constants into one." href="ReorderAssociativeOperator$.html"><span class="name">ReorderAssociativeOperator</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Reorder associative integral-type operators and fold all constants into one.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ReorderJoin" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ReorderJoin"></a><a id="ReorderJoin:ReorderJoin"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ReorderJoin$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Reorder the joins and push all the conditions into join, so that the bottom ones have at least one condition." href="ReorderJoin$.html"><span class="name">ReorderJoin</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Reorder the joins and push all the conditions into join, so that the bottom ones have at least
one condition.</p><div class="fullcomment"><div class="comment cmt"><p>Reorder the joins and push all the conditions into join, so that the bottom ones have at least
one condition.</p><p>The order of joins will not be changed if all of them already have at least one condition.</p><p>If star schema detection is enabled, reorder the star join plans based on heuristics.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ReplaceDeduplicateWithAggregate" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ReplaceDeduplicateWithAggregate"></a><a id="ReplaceDeduplicateWithAggregate:ReplaceDeduplicateWithAggregate"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ReplaceDeduplicateWithAggregate$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replaces logical Deduplicate operator with an Aggregate operator." href="ReplaceDeduplicateWithAggregate$.html"><span class="name">ReplaceDeduplicateWithAggregate</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replaces logical <span class="extype" name="Deduplicate">Deduplicate</span> operator with an <span class="extype" name="Aggregate">Aggregate</span> operator.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ReplaceDistinctWithAggregate" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ReplaceDistinctWithAggregate"></a><a id="ReplaceDistinctWithAggregate:ReplaceDistinctWithAggregate"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ReplaceDistinctWithAggregate$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replaces logical Distinct operator with an Aggregate operator." href="ReplaceDistinctWithAggregate$.html"><span class="name">ReplaceDistinctWithAggregate</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replaces logical <span class="extype" name="Distinct">Distinct</span> operator with an <span class="extype" name="Aggregate">Aggregate</span> operator.</p><div class="fullcomment"><div class="comment cmt"><p>Replaces logical <span class="extype" name="Distinct">Distinct</span> operator with an <span class="extype" name="Aggregate">Aggregate</span> operator.</p><pre>SELECT DISTINCT f1, f2 FROM t  =<span class="kw">=&gt;</span>  SELECT f1, f2 FROM t GROUP BY f1, f2</pre></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ReplaceExceptWithAntiJoin" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ReplaceExceptWithAntiJoin"></a><a id="ReplaceExceptWithAntiJoin:ReplaceExceptWithAntiJoin"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ReplaceExceptWithAntiJoin$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replaces logical Except operator with a left-anti Join operator." href="ReplaceExceptWithAntiJoin$.html"><span class="name">ReplaceExceptWithAntiJoin</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replaces logical <span class="extype" name="Except">Except</span> operator with a left-anti <span class="extype" name="Join">Join</span> operator.</p><div class="fullcomment"><div class="comment cmt"><p>Replaces logical <span class="extype" name="Except">Except</span> operator with a left-anti <span class="extype" name="Join">Join</span> operator.</p><pre>SELECT a1, a2 FROM Tab1 EXCEPT SELECT b1, b2 FROM Tab2
=<span class="kw">=&gt;</span>  SELECT DISTINCT a1, a2 FROM Tab1 LEFT ANTI JOIN Tab2 ON a1&lt;<span class="kw">=&gt;</span>b1 AND a2&lt;<span class="kw">=&gt;</span>b2</pre><p>Note:
1. This rule is only applicable to EXCEPT DISTINCT. Do not use it for EXCEPT ALL.
2. This rule has to be done after de-duplicating the attributes; otherwise, the generated
   join conditions will be incorrect.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ReplaceExceptWithFilter" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ReplaceExceptWithFilter"></a><a id="ReplaceExceptWithFilter:ReplaceExceptWithFilter"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ReplaceExceptWithFilter$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="If one or both of the datasets in the logical Except operator are purely transformed using Filter, this rule will replace logical Except operator with a Filter operator by flipping the filter condition of the right child." href="ReplaceExceptWithFilter$.html"><span class="name">ReplaceExceptWithFilter</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">If one or both of the datasets in the logical <span class="extype" name="Except">Except</span> operator are purely transformed using
<span class="extype" name="Filter">Filter</span>, this rule will replace logical <span class="extype" name="Except">Except</span> operator with a <span class="extype" name="Filter">Filter</span> operator by
flipping the filter condition of the right child.</p><div class="fullcomment"><div class="comment cmt"><p>If one or both of the datasets in the logical <span class="extype" name="Except">Except</span> operator are purely transformed using
<span class="extype" name="Filter">Filter</span>, this rule will replace logical <span class="extype" name="Except">Except</span> operator with a <span class="extype" name="Filter">Filter</span> operator by
flipping the filter condition of the right child.</p><pre>SELECT a1, a2 FROM Tab1 WHERE a2 = <span class="num">12</span> EXCEPT SELECT a1, a2 FROM Tab1 WHERE a1 = <span class="num">5</span>
=<span class="kw">=&gt;</span>  SELECT DISTINCT a1, a2 FROM Tab1 WHERE a2 = <span class="num">12</span> AND (a1 is <span class="kw">null</span> OR a1 &lt;&gt; <span class="num">5</span>)</pre><p>Note:
Before flipping the filter condition of the right node, we should:
1. Combine all it's <span class="extype" name="Filter">Filter</span>.
2. Update the attribute references to the left node;
3. Add a Coalesce(condition, False) (to take into account of NULL values in the condition).
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ReplaceExpressions" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ReplaceExpressions"></a><a id="ReplaceExpressions:ReplaceExpressions"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ReplaceExpressions$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Finds all the expressions that are unevaluable and replace/rewrite them with semantically equivalent expressions that can be evaluated." href="ReplaceExpressions$.html"><span class="name">ReplaceExpressions</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Finds all the expressions that are unevaluable and replace/rewrite them with semantically
equivalent expressions that can be evaluated.</p><div class="fullcomment"><div class="comment cmt"><p>Finds all the expressions that are unevaluable and replace/rewrite them with semantically
equivalent expressions that can be evaluated. Currently we replace two kinds of expressions:
1) <span class="extype" name="RuntimeReplaceable">RuntimeReplaceable</span> expressions
2) <span class="extype" name="UnevaluableAggregate">UnevaluableAggregate</span> expressions such as Every, Some, Any, CountIf
This is mainly used to provide compatibility with other databases.
Few examples are:
  we use this to support &quot;nvl&quot; by replacing it with &quot;coalesce&quot;.
  we use this to replace Every and Any with Min and Max respectively.</p><p>TODO: In future, explore an option to replace aggregate functions similar to
how RuntimeReplaceable does.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ReplaceIntersectWithSemiJoin" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ReplaceIntersectWithSemiJoin"></a><a id="ReplaceIntersectWithSemiJoin:ReplaceIntersectWithSemiJoin"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ReplaceIntersectWithSemiJoin$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replaces logical Intersect operator with a left-semi Join operator." href="ReplaceIntersectWithSemiJoin$.html"><span class="name">ReplaceIntersectWithSemiJoin</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replaces logical <span class="extype" name="Intersect">Intersect</span> operator with a left-semi <span class="extype" name="Join">Join</span> operator.</p><div class="fullcomment"><div class="comment cmt"><p>Replaces logical <span class="extype" name="Intersect">Intersect</span> operator with a left-semi <span class="extype" name="Join">Join</span> operator.</p><pre>SELECT a1, a2 FROM Tab1 INTERSECT SELECT b1, b2 FROM Tab2
=<span class="kw">=&gt;</span>  SELECT DISTINCT a1, a2 FROM Tab1 LEFT SEMI JOIN Tab2 ON a1&lt;<span class="kw">=&gt;</span>b1 AND a2&lt;<span class="kw">=&gt;</span>b2</pre><p>Note:
1. This rule is only applicable to INTERSECT DISTINCT. Do not use it for INTERSECT ALL.
2. This rule has to be done after de-duplicating the attributes; otherwise, the generated
   join conditions will be incorrect.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ReplaceNullWithFalseInPredicate" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ReplaceNullWithFalseInPredicate"></a><a id="ReplaceNullWithFalseInPredicate:ReplaceNullWithFalseInPredicate"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ReplaceNullWithFalseInPredicate$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="A rule that replaces Literal(null, BooleanType) with FalseLiteral, if possible, in the search condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator &quot;(search condition) = TRUE&quot;." href="ReplaceNullWithFalseInPredicate$.html"><span class="name">ReplaceNullWithFalseInPredicate</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">A rule that replaces <code>Literal(null, BooleanType)</code> with <code>FalseLiteral</code>, if possible, in the search
condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator
&quot;(search condition) = TRUE&quot;.</p><div class="fullcomment"><div class="comment cmt"><p>A rule that replaces <code>Literal(null, BooleanType)</code> with <code>FalseLiteral</code>, if possible, in the search
condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator
&quot;(search condition) = TRUE&quot;. The replacement is only valid when <code>Literal(null, BooleanType)</code> is
semantically equivalent to <code>FalseLiteral</code> when evaluating the whole search condition.</p><p>Please note that FALSE and NULL are not exchangeable in most cases, when the search condition
contains NOT and NULL-tolerant expressions. Thus, the rule is very conservative and applicable
in very limited cases.</p><p>For example, <code>Filter(Literal(null, BooleanType))</code> is equal to <code>Filter(FalseLiteral)</code>.</p><p>Another example containing branches is <code>Filter(If(cond, FalseLiteral, Literal(null, _)))</code>;
this can be optimized to <code>Filter(If(cond, FalseLiteral, FalseLiteral))</code>, and eventually
<code>Filter(FalseLiteral)</code>.</p><p>Moreover, this rule also transforms predicates in all <span class="extype" name="If">If</span> expressions as well as branch
conditions in all <span class="extype" name="CaseWhen">CaseWhen</span> expressions, even if they are not part of the search conditions.</p><p>For example, <code>Project(If(And(cond, Literal(null)), Literal(1), Literal(2)))</code> can be simplified
into <code>Project(Literal(2))</code>.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.ReplaceUpdateFieldsExpression" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ReplaceUpdateFieldsExpression"></a><a id="ReplaceUpdateFieldsExpression:ReplaceUpdateFieldsExpression"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/ReplaceUpdateFieldsExpression$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replaces UpdateFields expression with an evaluable expression." href="ReplaceUpdateFieldsExpression$.html"><span class="name">ReplaceUpdateFieldsExpression</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replaces <span class="extype" name="UpdateFields">UpdateFields</span> expression with an evaluable expression.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RewriteCorrelatedScalarSubquery" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="RewriteCorrelatedScalarSubquery"></a><a id="RewriteCorrelatedScalarSubquery:RewriteCorrelatedScalarSubquery"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RewriteCorrelatedScalarSubquery$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="This rule rewrites correlated ScalarSubquery expressions into LEFT OUTER joins." href="RewriteCorrelatedScalarSubquery$.html"><span class="name">RewriteCorrelatedScalarSubquery</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/AliasHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.AliasHelper">AliasHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">This rule rewrites correlated <span class="extype" name="ScalarSubquery">ScalarSubquery</span> expressions into LEFT OUTER joins.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RewriteDistinctAggregates" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RewriteDistinctAggregates"></a><a id="RewriteDistinctAggregates:RewriteDistinctAggregates"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RewriteDistinctAggregates$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="This rule rewrites an aggregate query with distinct aggregations into an expanded double aggregation in which the regular aggregation expressions and every distinct clause is aggregated in a separate group." href="RewriteDistinctAggregates$.html"><span class="name">RewriteDistinctAggregates</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">This rule rewrites an aggregate query with distinct aggregations into an expanded double
aggregation in which the regular aggregation expressions and every distinct clause is aggregated
in a separate group.</p><div class="fullcomment"><div class="comment cmt"><p>This rule rewrites an aggregate query with distinct aggregations into an expanded double
aggregation in which the regular aggregation expressions and every distinct clause is aggregated
in a separate group. The results are then combined in a second aggregate.</p><p>First example: query without filter clauses (in scala):</p><pre><span class="kw">val</span> data = <span class="std">Seq</span>(
  (<span class="lit">"a"</span>, <span class="lit">"ca1"</span>, <span class="lit">"cb1"</span>, <span class="num">10</span>),
  (<span class="lit">"a"</span>, <span class="lit">"ca1"</span>, <span class="lit">"cb2"</span>, <span class="num">5</span>),
  (<span class="lit">"b"</span>, <span class="lit">"ca1"</span>, <span class="lit">"cb1"</span>, <span class="num">13</span>))
  .toDF(<span class="lit">"key"</span>, <span class="lit">"cat1"</span>, <span class="lit">"cat2"</span>, <span class="lit">"value"</span>)
data.createOrReplaceTempView(<span class="lit">"data"</span>)

<span class="kw">val</span> agg = data.groupBy($<span class="lit">"key"</span>)
  .agg(
    count_distinct($<span class="lit">"cat1"</span>).as(<span class="lit">"cat1_cnt"</span>),
    count_distinct($<span class="lit">"cat2"</span>).as(<span class="lit">"cat2_cnt"</span>),
    sum($<span class="lit">"value"</span>).as(<span class="lit">"total"</span>))</pre><p>This translates to the following (pseudo) logical plan:</p><pre>Aggregate(
   key = ['key]
   functions = [COUNT(DISTINCT 'cat1),
                COUNT(DISTINCT 'cat2),
                sum('value)]
   output = [<span class="lit">'key, '</span>cat1_cnt, 'cat2_cnt, 'total])
  LocalTableScan [...]</pre><p>This rule rewrites this logical plan to the following (pseudo) logical plan:</p><pre>Aggregate(
   key = ['key]
   functions = [count('cat1) FILTER (WHERE 'gid = <span class="num">1</span>),
                count('cat2) FILTER (WHERE 'gid = <span class="num">2</span>),
                first('total) ignore nulls FILTER (WHERE 'gid = <span class="num">0</span>)]
   output = [<span class="lit">'key, '</span>cat1_cnt, 'cat2_cnt, 'total])
  Aggregate(
     key = [<span class="lit">'key, '</span>cat1, <span class="lit">'cat2, '</span>gid]
     functions = [sum('value)]
     output = [<span class="lit">'key, '</span>cat1, <span class="lit">'cat2, '</span>gid, 'total])
    Expand(
       projections = [('key, <span class="kw">null</span>, <span class="kw">null</span>, <span class="num">0</span>, cast('value as bigint)),
                      (<span class="lit">'key, '</span>cat1, <span class="kw">null</span>, <span class="num">1</span>, <span class="kw">null</span>),
                      ('key, <span class="kw">null</span>, 'cat2, <span class="num">2</span>, <span class="kw">null</span>)]
       output = [<span class="lit">'key, '</span>cat1, <span class="lit">'cat2, '</span>gid, 'value])
      LocalTableScan [...]</pre><p>Second example: aggregate function without distinct and with filter clauses (in sql):</p><pre>SELECT
  COUNT(DISTINCT cat1) as cat1_cnt,
  COUNT(DISTINCT cat2) as cat2_cnt,
  SUM(value) FILTER (WHERE id &gt; <span class="num">1</span>) AS total
FROM
  data
GROUP BY
  key</pre><p>This translates to the following (pseudo) logical plan:</p><pre>Aggregate(
   key = ['key]
   functions = [COUNT(DISTINCT 'cat1),
                COUNT(DISTINCT 'cat2),
                sum('value) FILTER (WHERE 'id &gt; <span class="num">1</span>)]
   output = [<span class="lit">'key, '</span>cat1_cnt, 'cat2_cnt, 'total])
  LocalTableScan [...]</pre><p>This rule rewrites this logical plan to the following (pseudo) logical plan:</p><pre>Aggregate(
   key = ['key]
   functions = [count('cat1) FILTER (WHERE 'gid = <span class="num">1</span>),
                count('cat2) FILTER (WHERE 'gid = <span class="num">2</span>),
                first('total) ignore nulls FILTER (WHERE 'gid = <span class="num">0</span>)]
   output = [<span class="lit">'key, '</span>cat1_cnt, 'cat2_cnt, 'total])
  Aggregate(
     key = [<span class="lit">'key, '</span>cat1, <span class="lit">'cat2, '</span>gid]
     functions = [sum('value) FILTER (WHERE 'id &gt; <span class="num">1</span>)]
     output = [<span class="lit">'key, '</span>cat1, <span class="lit">'cat2, '</span>gid, 'total])
    Expand(
       projections = [('key, <span class="kw">null</span>, <span class="kw">null</span>, <span class="num">0</span>, cast('value as bigint), 'id),
                      (<span class="lit">'key, '</span>cat1, <span class="kw">null</span>, <span class="num">1</span>, <span class="kw">null</span>, <span class="kw">null</span>),
                      ('key, <span class="kw">null</span>, 'cat2, <span class="num">2</span>, <span class="kw">null</span>, <span class="kw">null</span>)]
       output = [<span class="lit">'key, '</span>cat1, <span class="lit">'cat2, '</span>gid, 'value, 'id])
      LocalTableScan [...]</pre><p>Third example: aggregate function with distinct and filter clauses (in sql):</p><pre>SELECT
  COUNT(DISTINCT cat1) FILTER (WHERE id &gt; <span class="num">1</span>) as cat1_cnt,
  COUNT(DISTINCT cat2) FILTER (WHERE id &gt; <span class="num">2</span>) as cat2_cnt,
  SUM(value) FILTER (WHERE id &gt; <span class="num">3</span>) AS total
FROM
  data
GROUP BY
  key</pre><p>This translates to the following (pseudo) logical plan:</p><pre>Aggregate(
   key = ['key]
   functions = [COUNT(DISTINCT 'cat1) FILTER (WHERE 'id &gt; <span class="num">1</span>),
                COUNT(DISTINCT 'cat2) FILTER (WHERE 'id &gt; <span class="num">2</span>),
                sum('value) FILTER (WHERE 'id &gt; <span class="num">3</span>)]
   output = [<span class="lit">'key, '</span>cat1_cnt, 'cat2_cnt, 'total])
  LocalTableScan [...]</pre><p>This rule rewrites this logical plan to the following (pseudo) logical plan:</p><pre>Aggregate(
   key = ['key]
   functions = [count('cat1) FILTER (WHERE 'gid = <span class="num">1</span> and 'max_cond1),
                count('cat2) FILTER (WHERE 'gid = <span class="num">2</span> and 'max_cond2),
                first('total) ignore nulls FILTER (WHERE 'gid = <span class="num">0</span>)]
   output = [<span class="lit">'key, '</span>cat1_cnt, 'cat2_cnt, 'total])
  Aggregate(
     key = [<span class="lit">'key, '</span>cat1, <span class="lit">'cat2, '</span>gid]
     functions = [max('cond1), max('cond2), sum('value) FILTER (WHERE 'id &gt; <span class="num">3</span>)]
     output = [<span class="lit">'key, '</span>cat1, <span class="lit">'cat2, '</span>gid, 'max_cond1, 'max_cond2, 'total])
    Expand(
       projections = [('key, <span class="kw">null</span>, <span class="kw">null</span>, <span class="num">0</span>, <span class="kw">null</span>, <span class="kw">null</span>, cast('value as bigint), 'id),
                      (<span class="lit">'key, '</span>cat1, <span class="kw">null</span>, <span class="num">1</span>, 'id &gt; <span class="num">1</span>, <span class="kw">null</span>, <span class="kw">null</span>, <span class="kw">null</span>),
                      ('key, <span class="kw">null</span>, 'cat2, <span class="num">2</span>, <span class="kw">null</span>, 'id &gt; <span class="num">2</span>, <span class="kw">null</span>, <span class="kw">null</span>)]
       output = [<span class="lit">'key, '</span>cat1, <span class="lit">'cat2, '</span>gid, 'cond1, 'cond2, 'value, 'id])
      LocalTableScan [...]</pre><p>The rule does the following things here:
1. Expand the data. There are three aggregation groups in this query:</p><ol class="lowerRoman"><li>the non-distinct group;
   ii. the distinct 'cat1 group;
   iii. the distinct 'cat2 group.
   An expand operator is inserted to expand the child data for each group. The expand will null
   out all unused columns for the given group; this must be done in order to ensure correctness
   later on. Groups can by identified by a group id (gid) column added by the expand operator.
   If distinct group exists filter clause, the expand will calculate the filter and output it's
   result (e.g. cond1) which will be used to calculate the global conditions (e.g. max_cond1)
   equivalent to filter clauses.
2. De-duplicate the distinct paths and aggregate the non-aggregate path. The group by clause of
   this aggregate consists of the original group by clause, all the requested distinct columns
   and the group id. Both de-duplication of distinct column and the aggregation of the
   non-distinct group take advantage of the fact that we group by the group id (gid) and that we
   have nulled out all non-relevant columns the given group. If distinct group exists filter
   clause, we will use max to aggregate the results (e.g. cond1) of the filter output in the
   previous step. These aggregate will output the global conditions (e.g. max_cond1) equivalent
   to filter clauses.
3. Aggregating the distinct groups and combining this with the results of the non-distinct
   aggregation. In this step we use the group id and the global condition to filter the inputs
   for the aggregate functions. If the global condition (e.g. max_cond1) is true, it means at
   least one row of a distinct value satisfies the filter. This distinct value should be included
   in the aggregate function. The result of the non-distinct group are 'aggregated' by using
   the first operator, it might be more elegant to use the native UDAF merge mechanism for this
   in the future.</li></ol><p>This rule duplicates the input data by two or more times (# distinct groups + an optional
non-distinct group). This will put quite a bit of memory pressure of the used aggregate and
exchange operators. Keeping the number of distinct groups as low as possible should be priority,
we could improve this in the current rule by applying more advanced expression canonicalization
techniques.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RewriteExceptAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RewriteExceptAll"></a><a id="RewriteExceptAll:RewriteExceptAll"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RewriteExceptAll$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replaces logical Except operator using a combination of Union, Aggregate and Generate operator." href="RewriteExceptAll$.html"><span class="name">RewriteExceptAll</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replaces logical <span class="extype" name="Except">Except</span> operator using a combination of Union, Aggregate
and Generate operator.</p><div class="fullcomment"><div class="comment cmt"><p>Replaces logical <span class="extype" name="Except">Except</span> operator using a combination of Union, Aggregate
and Generate operator.</p><p>Input Query :</p><pre>SELECT c1 FROM ut1 EXCEPT ALL SELECT c1 FROM ut2</pre><p>Rewritten Query:</p><pre>SELECT c1
FROM (
  SELECT replicate_rows(sum_val, c1)
    FROM (
      SELECT c1, sum_val
        FROM (
          SELECT c1, sum(vcol) AS sum_val
            FROM (
              SELECT <span class="num">1</span>L as vcol, c1 FROM ut1
              UNION ALL
              SELECT -<span class="num">1</span>L as vcol, c1 FROM ut2
           ) AS union_all
         GROUP BY union_all.c1
       )
     WHERE sum_val &gt; <span class="num">0</span>
    )
)</pre></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RewriteIntersectAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RewriteIntersectAll"></a><a id="RewriteIntersectAll:RewriteIntersectAll"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RewriteIntersectAll$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replaces logical Intersect operator using a combination of Union, Aggregate and Generate operator." href="RewriteIntersectAll$.html"><span class="name">RewriteIntersectAll</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replaces logical <span class="extype" name="Intersect">Intersect</span> operator using a combination of Union, Aggregate
and Generate operator.</p><div class="fullcomment"><div class="comment cmt"><p>Replaces logical <span class="extype" name="Intersect">Intersect</span> operator using a combination of Union, Aggregate
and Generate operator.</p><p>Input Query :</p><pre>SELECT c1 FROM ut1 INTERSECT ALL SELECT c1 FROM ut2</pre><p>Rewritten Query:</p><pre>SELECT c1
FROM (
     SELECT replicate_row(min_count, c1)
     FROM (
          SELECT c1, If (vcol1_cnt &gt; vcol2_cnt, vcol2_cnt, vcol1_cnt) AS min_count
          FROM (
               SELECT   c1, count(vcol1) as vcol1_cnt, count(vcol2) as vcol2_cnt
               FROM (
                    SELECT <span class="kw">true</span> as vcol1, <span class="kw">null</span> as , c1 FROM ut1
                    UNION ALL
                    SELECT <span class="kw">null</span> as vcol1, <span class="kw">true</span> as vcol2, c1 FROM ut2
                    ) AS union_all
               GROUP BY c1
               HAVING vcol1_cnt &gt;= <span class="num">1</span> AND vcol2_cnt &gt;= <span class="num">1</span>
               )
          )
      )</pre></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RewriteLateralSubquery" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="RewriteLateralSubquery"></a><a id="RewriteLateralSubquery:RewriteLateralSubquery"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RewriteLateralSubquery$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="This rule rewrites LateralSubquery expressions into joins." href="RewriteLateralSubquery$.html"><span class="name">RewriteLateralSubquery</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">This rule rewrites <span class="extype" name="LateralSubquery">LateralSubquery</span> expressions into joins.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RewriteNonCorrelatedExists" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="RewriteNonCorrelatedExists"></a><a id="RewriteNonCorrelatedExists:RewriteNonCorrelatedExists"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RewriteNonCorrelatedExists$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Rewrite non correlated exists subquery to use ScalarSubquery WHERE EXISTS (SELECT A FROM TABLE B WHERE COL1 &gt; 10) will be rewritten to WHERE (SELECT 1 FROM (SELECT A FROM TABLE B WHERE COL1 &gt; 10) LIMIT 1) IS NOT NULL" href="RewriteNonCorrelatedExists$.html"><span class="name">RewriteNonCorrelatedExists</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Rewrite non correlated exists subquery to use ScalarSubquery
  WHERE EXISTS (SELECT A FROM TABLE B WHERE COL1 &gt; 10)
will be rewritten to
  WHERE (SELECT 1 FROM (SELECT A FROM TABLE B WHERE COL1 &gt; 10) LIMIT 1) IS NOT NULL
</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.RewritePredicateSubquery" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RewritePredicateSubquery"></a><a id="RewritePredicateSubquery:RewritePredicateSubquery"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/RewritePredicateSubquery$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="This rule rewrites predicate sub-queries into left semi/anti joins." href="RewritePredicateSubquery$.html"><span class="name">RewritePredicateSubquery</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">This rule rewrites predicate sub-queries into left semi/anti joins.</p><div class="fullcomment"><div class="comment cmt"><p>This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates
are supported:
a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter
   will be pulled out as the join conditions.
b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will
   be pulled out as join conditions, value = selected column will also be used as join
   condition.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.SimpleTestOptimizer" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SimpleTestOptimizer"></a><a id="SimpleTestOptimizer:SimpleTestOptimizer"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/SimpleTestOptimizer$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="An optimizer used in test code." href="SimpleTestOptimizer$.html"><span class="name">SimpleTestOptimizer</span></a><span class="result"> extends <a href="SimpleTestOptimizer.html" class="extype" name="org.apache.spark.sql.catalyst.optimizer.SimpleTestOptimizer">SimpleTestOptimizer</a></span>
      </span>
      
      <p class="shortcomment cmt">An optimizer used in test code.</p><div class="fullcomment"><div class="comment cmt"><p>An optimizer used in test code.</p><p>To ensure extendability, we leave the standard rules in the abstract optimizer rules, while
specific rules go to the subclasses
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.SimplifyBinaryComparison" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SimplifyBinaryComparison"></a><a id="SimplifyBinaryComparison:SimplifyBinaryComparison"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/SimplifyBinaryComparison$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Simplifies binary comparisons with semantically-equal expressions: 1) Replace '&lt;=&gt;' with 'true' literal." href="SimplifyBinaryComparison$.html"><span class="name">SimplifyBinaryComparison</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a> with <a href="../plans/logical/ConstraintHelper.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.ConstraintHelper">ConstraintHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Simplifies binary comparisons with semantically-equal expressions:
1) Replace '&lt;=&gt;' with 'true' literal.</p><div class="fullcomment"><div class="comment cmt"><p>Simplifies binary comparisons with semantically-equal expressions:
1) Replace '&lt;=&gt;' with 'true' literal.
2) Replace '=', '&lt;=', and '&gt;=' with 'true' literal if both operands are non-nullable.
3) Replace '&lt;' and '&gt;' with 'false' literal if both operands are non-nullable.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.SimplifyCaseConversionExpressions" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SimplifyCaseConversionExpressions"></a><a id="SimplifyCaseConversionExpressions:SimplifyCaseConversionExpressions"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/SimplifyCaseConversionExpressions$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Removes the inner case conversion expressions that are unnecessary because the inner conversion is overwritten by the outer one." href="SimplifyCaseConversionExpressions$.html"><span class="name">SimplifyCaseConversionExpressions</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Removes the inner case conversion expressions that are unnecessary because
the inner conversion is overwritten by the outer one.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.SimplifyCasts" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SimplifyCasts"></a><a id="SimplifyCasts:SimplifyCasts"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/SimplifyCasts$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Removes Casts that are unnecessary because the input is already the correct type." href="SimplifyCasts$.html"><span class="name">SimplifyCasts</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Removes <span class="extype" name="Cast">Casts</span> that are unnecessary because the input is already the correct type.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.SimplifyConditionals" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SimplifyConditionals"></a><a id="SimplifyConditionals:SimplifyConditionals"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/SimplifyConditionals$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Simplifies conditional expressions (if / case)." href="SimplifyConditionals$.html"><span class="name">SimplifyConditionals</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>] with <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Simplifies conditional expressions (if / case).</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.SimplifyConditionalsInPredicate" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SimplifyConditionalsInPredicate"></a><a id="SimplifyConditionalsInPredicate:SimplifyConditionalsInPredicate"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/SimplifyConditionalsInPredicate$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="A rule that converts conditional expressions to predicate expressions, if possible, in the search condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator &quot;(search condition) = TRUE&quot;." href="SimplifyConditionalsInPredicate$.html"><span class="name">SimplifyConditionalsInPredicate</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">A rule that converts conditional expressions to predicate expressions, if possible, in the
search condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator
&quot;(search condition) = TRUE&quot;.</p><div class="fullcomment"><div class="comment cmt"><p>A rule that converts conditional expressions to predicate expressions, if possible, in the
search condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator
&quot;(search condition) = TRUE&quot;. After this converting, we can potentially push the filter down to
the data source. This rule is null-safe.</p><p>Supported cases are:
- IF(cond, trueVal, false)                   =&gt; AND(cond, trueVal)
- IF(cond, trueVal, true)                    =&gt; OR(NOT(cond), trueVal)
- IF(cond, false, falseVal)                  =&gt; AND(NOT(cond), falseVal)
- IF(cond, true, falseVal)                   =&gt; OR(cond, falseVal)
- CASE WHEN cond THEN trueVal ELSE false END =&gt; AND(cond, trueVal)
- CASE WHEN cond THEN trueVal END            =&gt; AND(cond, trueVal)
- CASE WHEN cond THEN trueVal ELSE null END  =&gt; AND(cond, trueVal)
- CASE WHEN cond THEN trueVal ELSE true END  =&gt; OR(NOT(cond), trueVal)
- CASE WHEN cond THEN false ELSE elseVal END =&gt; AND(NOT(cond), elseVal)
- CASE WHEN cond THEN true ELSE elseVal END  =&gt; OR(cond, elseVal)
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.SimplifyExtractValueOps" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SimplifyExtractValueOps"></a><a id="SimplifyExtractValueOps:SimplifyExtractValueOps"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/SimplifyExtractValueOps$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Simplify redundant CreateNamedStruct, CreateArray and CreateMap expressions." href="SimplifyExtractValueOps$.html"><span class="name">SimplifyExtractValueOps</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Simplify redundant <span class="extype" name="CreateNamedStruct">CreateNamedStruct</span>, <span class="extype" name="CreateArray">CreateArray</span> and <span class="extype" name="CreateMap">CreateMap</span> expressions.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.SpecialDatetimeValues" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SpecialDatetimeValues"></a><a id="SpecialDatetimeValues:SpecialDatetimeValues"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/SpecialDatetimeValues$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Replaces casts of special datetime strings by its date/timestamp values if the input strings are foldable." href="SpecialDatetimeValues$.html"><span class="name">SpecialDatetimeValues</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Replaces casts of special datetime strings by its date/timestamp values
if the input strings are foldable.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.StarSchemaDetection" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="StarSchemaDetection"></a><a id="StarSchemaDetection:StarSchemaDetection"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/StarSchemaDetection$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Encapsulates star-schema detection logic." href="StarSchemaDetection$.html"><span class="name">StarSchemaDetection</span></a><span class="result"> extends <a href="../expressions/PredicateHelper.html" class="extype" name="org.apache.spark.sql.catalyst.expressions.PredicateHelper">PredicateHelper</a> with <a href="../SQLConfHelper.html" class="extype" name="org.apache.spark.sql.catalyst.SQLConfHelper">SQLConfHelper</a></span>
      </span>
      
      <p class="shortcomment cmt">Encapsulates star-schema detection logic.</p>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.TransposeWindow" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TransposeWindow"></a><a id="TransposeWindow:TransposeWindow"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/TransposeWindow$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Transpose Adjacent Window Expressions." href="TransposeWindow$.html"><span class="name">TransposeWindow</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Transpose Adjacent Window Expressions.</p><div class="fullcomment"><div class="comment cmt"><p>Transpose Adjacent Window Expressions.
- If the partition spec of the parent Window expression is compatible with the partition spec
  of the child window expression, transpose them.
</p></div></div>
    </li><li name="org.apache.spark.sql.catalyst.optimizer.UnwrapCastInBinaryComparison" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="UnwrapCastInBinaryComparison"></a><a id="UnwrapCastInBinaryComparison:UnwrapCastInBinaryComparison"></a>
      <span class="permalink">
      <a href="../../../../../../org/apache/spark/sql/catalyst/optimizer/UnwrapCastInBinaryComparison$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Unwrap casts in binary comparison or In/InSet operations with patterns like following:" href="UnwrapCastInBinaryComparison$.html"><span class="name">UnwrapCastInBinaryComparison</span></a><span class="result"> extends <a href="../rules/Rule.html" class="extype" name="org.apache.spark.sql.catalyst.rules.Rule">Rule</a>[<a href="../plans/logical/LogicalPlan.html" class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalPlan">LogicalPlan</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Unwrap casts in binary comparison or <code>In/InSet</code> operations with patterns like following:</p><div class="fullcomment"><div class="comment cmt"><p>Unwrap casts in binary comparison or <code>In/InSet</code> operations with patterns like following:</p><p>- <code>BinaryComparison(Cast(fromExp, toType), Literal(value, toType))</code>
- <code>BinaryComparison(Literal(value, toType), Cast(fromExp, toType))</code>
- <code>In(Cast(fromExp, toType), Seq(Literal(v1, toType), Literal(v2, toType), ...)</code>
- <code>InSet(Cast(fromExp, toType), Set(v1, v2, ...))</code></p><p>This rule optimizes expressions with the above pattern by either replacing the cast with simpler
constructs, or moving the cast from the expression side to the literal side, which enables them
to be optimized away later and pushed down to data sources.</p><p>Currently this only handles cases where:
  1). <code>fromType</code> (of <code>fromExp</code>) and <code>toType</code> are of numeric types (i.e., short, int, float,
    decimal, etc)
  2). <code>fromType</code> can be safely coerced to <code>toType</code> without precision loss (e.g., short to int,
    int to long, but not long to int)</p><p>If the above conditions are satisfied, the rule checks to see if the literal <code>value</code> is within
range <code>(min, max)</code>, where <code>min</code> and <code>max</code> are the minimum and maximum value of <code>fromType</code>,
respectively. If this is true then it means we may safely cast <code>value</code> to <code>fromType</code> and thus
able to move the cast to the literal side. That is:</p><p>  <code>cast(fromExp, toType) op value</code> ==&gt; <code>fromExp op cast(value, fromType)</code></p><p>Note there are some exceptions to the above: if casting from <code>value</code> to <code>fromType</code> causes
rounding up or down, the above conversion will no longer be valid. Instead, the rule does the
following:</p><p>if casting <code>value</code> to <code>fromType</code> causes rounding up:</p><ul><li><code>cast(fromExp, toType) &gt; value</code> ==&gt; <code>fromExp &gt;= cast(value, fromType)</code></li><li><code>cast(fromExp, toType) &gt;= value</code> ==&gt; <code>fromExp &gt;= cast(value, fromType)</code></li><li><code>cast(fromExp, toType) === value</code> ==&gt; if(isnull(fromExp), null, false)</li><li><code>cast(fromExp, toType) &lt;=&gt; value</code> ==&gt; false (if <code>fromExp</code> is deterministic)</li><li><code>cast(fromExp, toType) &lt;= value</code> ==&gt; <code>fromExp &lt; cast(value, fromType)</code></li><li><code>cast(fromExp, toType) &lt; value</code> ==&gt; <code>fromExp &lt; cast(value, fromType)</code></li></ul><p>Similarly for the case when casting <code>value</code> to <code>fromType</code> causes rounding down.</p><p>If the <code>value</code> is not within range <code>(min, max)</code>, the rule breaks the scenario into different
cases and try to replace each with simpler constructs.</p><p>if <code>value &gt; max</code>, the cases are of following:</p><ul><li><code>cast(fromExp, toType) &gt; value</code> ==&gt; if(isnull(fromExp), null, false)</li><li><code>cast(fromExp, toType) &gt;= value</code> ==&gt; if(isnull(fromExp), null, false)</li><li><code>cast(fromExp, toType) === value</code> ==&gt; if(isnull(fromExp), null, false)</li><li><code>cast(fromExp, toType) &lt;=&gt; value</code> ==&gt; false (if <code>fromExp</code> is deterministic)</li><li><code>cast(fromExp, toType) &lt;= value</code> ==&gt; if(isnull(fromExp), null, true)</li><li><code>cast(fromExp, toType) &lt; value</code> ==&gt; if(isnull(fromExp), null, true)</li></ul><p>if <code>value == max</code>, the cases are of following:</p><ul><li><code>cast(fromExp, toType) &gt; value</code> ==&gt; if(isnull(fromExp), null, false)</li><li><code>cast(fromExp, toType) &gt;= value</code> ==&gt; fromExp == max</li><li><code>cast(fromExp, toType) === value</code> ==&gt; fromExp == max</li><li><code>cast(fromExp, toType) &lt;=&gt; value</code> ==&gt; fromExp &lt;=&gt; max</li><li><code>cast(fromExp, toType) &lt;= value</code> ==&gt; if(isnull(fromExp), null, true)</li><li><code>cast(fromExp, toType) &lt; value</code> ==&gt; fromExp =!= max</li></ul><p>Similarly for the cases when <code>value == min</code> and <code>value &lt; min</code>.</p><p>Further, the above <code>if(isnull(fromExp), null, false)</code> is represented using conjunction
<code>and(isnull(fromExp), null)</code>, to enable further optimization and filter pushdown to data sources.
Similarly, <code>if(isnull(fromExp), null, true)</code> is represented with <code>or(isnotnull(fromExp), null)</code>.</p><p>For <code>In/InSet</code> operation, first the rule transform the expression to Equals:
<code>Seq(
  EqualTo(Cast(fromExp, toType), Literal(v1, toType)),
  EqualTo(Cast(fromExp, toType), Literal(v2, toType)),
  ...
)</code>
and using the same rule with <code>BinaryComparison</code> show as before to optimize each <code>EqualTo</code>.
</p></div></div>
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
